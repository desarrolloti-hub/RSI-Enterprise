<!DOCTYPE html>
<html lang="es">
<head>
    <link rel="manifest" href="../../manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tickets | RSI Enterprise</title>
    <link rel="stylesheet" href="gestion_Tickets.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- jsPDF para generar PDFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
    <!-- Imagen de fondo -->
    <div class="../css/img/Logo-RSI-OFICIAL.png"></div>
    <!-- SIDEBAR -->
    <div class="sidebar">
        <div class="user-profile">
            <img id="userAvatar" src="https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png" alt="Logo RSI" class="user-avatar">
            <h2 class="user-name" id="userNameDisplay">Cargando...</h2>
            <span class="user-area" id="userAreaDisplay">ÁREA: Cargando...</span>
        </div>


 <div class="logout-container">
            <button class="logout-btn" id="logoutBtn">
                <i class="fas fa-sign-out-alt"></i> Cerrar Sesión
            </button>
            
            <button class="asistencia-btn" id="endAssistanceBtn">
                <i class="fas fa-user-clock"></i> Terminar Asistencia
            </button>
            
            <button class="asistencia-btn" id="createTicketBtn" style="display: none;">
                <i class="fas fa-plus-circle"></i> Levantar Ticket
            </button>
            
   



        <div class="stats-header">
            <h3 class="stats-title">Mis Estadísticas</h3>
        </div>

        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-title"><i class="fas fa-ticket-alt"></i> Total Tickets</div>
                <div id="totalTickets" class="stat-value">0</div>
                <div class="stat-trend trend-up">
                    <i class="fas fa-arrow-up"></i> <span>5% vs último mes</span>
                </div>
            </div>
            <div class="stat-card">
                <div class="stat-title"><i class="fas fa-clock"></i> Tiempo promedio</div>
                <div id="avgTime" class="stat-value">0 días</div>
                <div class="stat-trend trend-down">
                    <i class="fas fa-arrow-down"></i> <span>2 días menos</span>
                </div>
            </div>
        </div>

        <div class="tickets-chart">
            <div class="chart-title">Estado de mis tickets</div>
            <div class="chart-bars" id="statusChart">
                <!-- Se llenará dinámicamente -->
            </div>
        </div>
        

        <div class="priority-stats">
            <div class="chart-title">Tickets por Prioridad</div>
            <div class="priority-item">
                <span class="priority-name">
                    <span class="priority-indicator priority-high"></span> Alta
                </span>
                <span id="highPriority" class="priority-count">0</span>
            </div>
            <div class="priority-item">
                <span class="priority-name">
                    <span class="priority-indicator priority-medium"></span> Media
                </span>
                <span id="mediumPriority" class="priority-count">0</span>
            </div>
            <div class="priority-item">
                <span class="priority-name">
                    <span class="priority-indicator priority-low"></span> Baja
                </span>
                <span id="lowPriority" class="priority-count">0</span>
            </div>
        </div><br>

       

<!-- Mensaje de estado (ya existente) -->
<div id="mensajeAcceso" style="display: none;">
 
</div>
        </div>
        
    </div>

    <!-- MAIN CONTENT -->
    <div class="main-content">
        <div class="crud-header">
            
            <center>
            <h1 class="page-title">Mis Tickets</h1>
            </center>

            <!-- Botón de filtro -->
            <button class="filter-btn" id="filterBtn">
                <i class="fas fa-filter"></i> 
                <span id="filterText">Ver Finalizados</span>
            </button>
        </div>

        <div class="tickets-grid" id="ticketsContainer">
            <!-- Los tickets se cargarán dinámicamente aquí -->
            <div class="no-tickets">
                <i class="fas fa-ticket-alt"></i>
                <h3>Cargando tickets...</h3>
                <p>Por favor espera mientras se cargan tus tickets</p>
            </div>
        </div>
    </div>

<!-- Modal para detalles del ticket -->
<div id="detailModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="detailTitle">Detalles del Ticket</h2>
            <span class="close">&times;</span>
        </div>
        <div id="detailContent">
            <!-- El contenido se cargará dinámicamente -->
        </div>
        <div class="modal-footer">
            <button type="button" class="action-btn finish-btn" id="finishTicketBtn">
                <i class="fas fa-check-circle"></i> Finalizar Ticket
            </button>
            <button type="button" class="action-btn edit-btn" id="editFinishBtn" style="display: none;">
                <i class="fas fa-edit"></i> Modificar Finalización
            </button>
            <button type="button" class="cancel-btn" id="closeDetailBtn">
                <i class="fas fa-times"></i> Cerrar
            </button>
        </div>
    </div>
</div>

<!-- Modal para finalizar/editar ticket -->
<div id="finishModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="finishModalTitle">Finalizar Ticket</h2>
            <span class="close">&times;</span>
        </div>
        <div class="modal-body">
            <form id="finishForm">
                <div class="form-group">
                    <label for="projectDescription">Descripción del proyecto finalizado</label>
                    <textarea 
                        id="projectDescription" 
                        class="form-control" 
                        rows="8" 
                        minlength="10" 
                        maxlength="10000" 
                        placeholder="Describa en detalle el trabajo realizado (mínimo 10 caracteres, máximo 10,000 caracteres)"
                        required></textarea>
                    <div class="char-counter">
                        <span id="charCount">0</span>/10,000 caracteres
                    </div>
                </div>
                <div class="form-group">
                    <label for="imageUpload">Subir evidencia (1-10 imágenes)</label>
                    <input type="file" id="imageUpload" accept="image/*" class="form-control" multiple>
                    <small class="form-text text-muted">Puedes seleccionar hasta 10 imágenes</small>
                </div>
                <div class="image-preview-container" id="imagePreviewContainer">
                    <!-- Vista previa de imágenes existentes -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="cancel-btn" id="closeDetailBtn">
                        <i class="fas fa-times"></i> Cancelar
                    </button>
                    <button type="submit" class="action-btn confirm-btn">
                        <i class="fas fa-check"></i> Guardar
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Modal para visualización de imágenes -->
<div id="imageViewerModal" class="modal">
    <div class="modal-content" style="max-width: 90%; max-height: 90vh; background: transparent; box-shadow: none;">
        <span class="close" style="position: absolute; top: 15px; right: 15px; color: rgb(0, 0, 0); font-size: 35px; z-index: 100;">&times;</span>
        <img id="expandedImage" style="width: 100%; height: auto; max-height: 90vh; object-fit: contain;">
    </div>
</div>

<!-- Modal de progreso para PDF -->
<div id="pdfProgressModal" class="modal">
    <div class="modal-content" style="text-align: center;">
        <div class="modal-header">
            <h2>Generando PDF</h2>
        </div>
        <div class="modal-body">
            <div class="pdf-progress">
                <i class="fas fa-file-pdf fa-3x" style="color: #e74c3c; margin-bottom: 20px;"></i>
                <p>Procesando información del ticket...</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="pdfProgressFill"></div>
                </div>
                <p id="pdfProgressText">0%</p>
            </div>
        </div>
    </div>
</div>


<script type="module">
// Esquemas de datos
const DataSchemas = {
    EVIDENCIA: {
        ticketId: '',
        colaboradorId: '',
        colaboradorNombre: '',
        descripcion: '',
        imagenes: [],
        fechaCreacion: null,
        fechaActualizacion: null,
        estado: 'pendiente' // pendiente | completado
    },
    TICKET: {
        // ... (tus campos actuales)
        evidenciasCompletadas: [], // array de colaboradorIds que han completado
        todosCompletados: false
    },
    PDF: {
        ticketId: '',
        nombreArchivo: '',
        fechaCreacion: null,
        colaboradorId: '',
        colaboradorNombre: '',
        contenido: '', // base64 del PDF
        tamaño: 0
    }
};

// Clase para manejar el estado del ticket
class TicketManager {
    constructor() {
        this.currentTicketId = null;
        this.currentTicketStatus = null;
        this.selectedImages = [];
        this.existingImages = [];
        this.showFinalized = false; // Estado del filtro
    }

    setCurrentTicket(ticketId, status) {
        this.currentTicketId = ticketId;
        this.currentTicketStatus = status;
    }

    addSelectedImage(image) {
        this.selectedImages.push(image);
    }

    removeSelectedImage(index) {
        this.selectedImages.splice(index, 1);
    }

    setExistingImages(images) {
        this.existingImages = images || [];
    }

    removeExistingImage(index) {
        this.existingImages.splice(index, 1);
    }

    getAllImages() {
        return [...this.existingImages, ...this.selectedImages];
    }

    clearCurrentTicket() {
        this.currentTicketId = null;
        this.currentTicketStatus = null;
        this.selectedImages = [];
        this.existingImages = [];
    }

    toggleFilter() {
        this.showFinalized = !this.showFinalized;
        return this.showFinalized;
    }
}

// Instancia única del manager
const ticketManager = new TicketManager();

// Importar módulos necesarios de Firebase v9
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
import { 
    getFirestore, 
    collection, 
    query, 
    where,
    getDocs,
    orderBy,
    doc,
    getDoc,
    limit,
    updateDoc,
    addDoc,
    serverTimestamp
} from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
import { 
    getAuth, 
    GoogleAuthProvider, 
    signInWithPopup, 
    signOut,
    onAuthStateChanged
} from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";

// Configuración de Firebase CORREGIDA
const firebaseConfig = {
    apiKey: "AIzaSyBJy992gkvsT77-_fMp_O_z99wtjZiK77Y",
    authDomain: "rsienterprise.firebaseapp.com",
    databaseURL: "https://rsienterprise-default-rtdb.firebaseio.com",
    projectId: "rsienterprise", // CORREGIDO: era "rsienterprime"
    storageBucket: "rsienterprise.appspot.com",
    messagingSenderId: "1063117165770",
    appId: "1:1063117165770:web:8555f26b25ae80bc42d033",
    measurementId: "G-38F2DBG9HE"
};

// Inicializar Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
const provider = new GoogleAuthProvider();

// Configurar el proveedor de Google
provider.addScope('email');
provider.addScope('profile');

// Elementos del DOM
const DOM = {
    userAvatar: document.getElementById('userAvatar'),
    userNameDisplay: document.getElementById('userNameDisplay'),
    userAreaDisplay: document.getElementById('userAreaDisplay'),
    ticketsContainer: document.getElementById('ticketsContainer'),
    totalTickets: document.getElementById('totalTickets'),
    avgTime: document.getElementById('avgTime'),
    highPriority: document.getElementById('highPriority'),
    mediumPriority: document.getElementById('mediumPriority'),
    lowPriority: document.getElementById('lowPriority'),
    statusChart: document.getElementById('statusChart'),
    logoutBtn: document.getElementById('logoutBtn'),
    endAssistanceBtn: document.getElementById('endAssistanceBtn'),
    filterBtn: document.getElementById('filterBtn'),
    filterText: document.getElementById('filterText')
};

// Estado de la aplicación
const AppState = {
    currentUser: null,
    userData: null,
    userRole: null,
    lastCheckedTicketId: null,
    ticketCheckInterval: null,
    notificationCheckInterval: 10000, // 10 segundos inicialmente
    allTickets: [] // Almacenar todos los tickets
};

// En tu módulo principal, después de definir AppState:
window.AppState = AppState;
// Disparar evento cuando esté listo
document.dispatchEvent(new Event('AppStateReady'));

// Generador de PDF
class PDFGenerator {
    constructor() {
        this.jsPDF = window.jspdf.jsPDF;
    }

    async generateTicketPDF(ticketData, evidencias) {
        try {
            this.showProgressModal();
            this.updateProgress(10, 'Inicializando generador PDF...');

            const pdf = new this.jsPDF('p', 'mm', 'a4');
            const pageWidth = pdf.internal.pageSize.getWidth();
            const pageHeight = pdf.internal.pageSize.getHeight();
            let yPosition = 20;

            // Header con logo
            this.updateProgress(20, 'Añadiendo header...');
            await this.addHeader(pdf, pageWidth, yPosition);
            yPosition += 40;

            // Información básica del ticket
            this.updateProgress(30, 'Añadiendo información básica...');
            yPosition = this.addBasicInfo(pdf, ticketData, yPosition, pageWidth);

            // Información adicional
            this.updateProgress(40, 'Añadiendo información adicional...');
            yPosition = this.addAdditionalInfo(pdf, ticketData, yPosition, pageWidth);

            // Evidencias de colaboradores
            this.updateProgress(50, 'Procesando evidencias...');
            if (evidencias && evidencias.length > 0) {
                for (let i = 0; i < evidencias.length; i++) {
                    this.updateProgress(50 + (i / evidencias.length) * 40, 'Añadiendo evidencias...');
                    yPosition = await this.addEvidenceSection(pdf, evidencias[i], yPosition, pageWidth, pageHeight);
                }
            }

            this.updateProgress(95, 'Finalizando PDF...');
            
            // Guardar en Firebase
            const pdfBase64 = pdf.output('datauristring');
            await this.savePDFToFirebase(ticketData.id, pdfBase64);

            this.updateProgress(100, 'PDF generado exitosamente');
            
            // Descargar PDF
            const fileName = `Ticket_${ticketData.id.substring(0, 8)}_${new Date().toISOString().split('T')[0]}.pdf`;
            pdf.save(fileName);

            setTimeout(() => {
                this.hideProgressModal();
                Swal.fire({
                    icon: 'success',
                    title: 'PDF Generado',
                    text: 'El PDF se ha generado y guardado exitosamente',
                    confirmButtonColor: '#3085d6'
                });
            }, 1000);

        } catch (error) {
            console.error('Error generando PDF:', error);
            this.hideProgressModal();
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: 'No se pudo generar el PDF: ' + error.message,
                confirmButtonColor: '#3085d6'
            });
        }
    }

    async addHeader(pdf, pageWidth, yPosition) {
        // Título principal
        pdf.setFontSize(20);
        pdf.setFont('helvetica', 'bold');
        pdf.setTextColor(102, 126, 234);
        pdf.text('REPORTE DE TICKET - RSI ENTERPRISE', pageWidth / 2, yPosition, { align: 'center' });
        
        // Línea decorativa
        pdf.setDrawColor(102, 126, 234);
        pdf.setLineWidth(2);
        pdf.line(20, yPosition + 5, pageWidth - 20, yPosition + 5);
        
        // Fecha de generación
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        pdf.setTextColor(100, 100, 100);
        pdf.text(`Generado el: ${new Date().toLocaleDateString('es-MX')} a las ${new Date().toLocaleTimeString('es-MX')}`, pageWidth - 20, yPosition + 15, { align: 'right' });
    }

    addBasicInfo(pdf, ticketData, yPosition, pageWidth) {
        const shortId = ticketData.id.substring(0, 8);
        
        // Título de sección
        pdf.setFontSize(14);
        pdf.setFont('helvetica', 'bold');
        pdf.setTextColor(44, 62, 80);
        pdf.text('INFORMACIÓN BÁSICA', 20, yPosition);
        yPosition += 10;

        // Crear tabla de información básica
        const basicInfo = [
            ['ID del Ticket:', `#${shortId.toUpperCase()}`],
            ['Título:', ticketData.titulo || 'Sin título'],
            ['Estado:', (ticketData.estado || 'desconocido').replace('_', ' ').toUpperCase()],
            ['Prioridad:', (ticketData.prioridad || 'media').toUpperCase()],
            ['Área:', ticketData.area || 'General'],
            ['Responsable:', ticketData.responsableNombre || 'No asignado'],
            ['Fecha de Creación:', this.formatDate(ticketData.fechaCreacion)],
            ['Última Actualización:', this.formatDate(ticketData.fechaActualizacion)],
        ];

        if (ticketData.fechaFinalizacion) {
            basicInfo.push(['Fecha de Finalización:', this.formatDate(ticketData.fechaFinalizacion)]);
        }

        yPosition = this.addTable(pdf, basicInfo, yPosition, pageWidth);
        
        return yPosition + 10;
    }

    addAdditionalInfo(pdf, ticketData, yPosition, pageWidth) {
        // Descripción del ticket
        if (ticketData.descripcionActividades) {
            pdf.setFontSize(14);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(44, 62, 80);
            pdf.text('DESCRIPCIÓN DEL PROYECTO', 20, yPosition);
            yPosition += 10;

            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(0, 0, 0);
            
            const splitDescription = pdf.splitTextToSize(ticketData.descripcionActividades, pageWidth - 40);
            pdf.text(splitDescription, 20, yPosition);
            yPosition += splitDescription.length * 5 + 10;
        }

        // Información adicional si existe
        const additionalData = [];
        if (ticketData.servicio) additionalData.push(['Servicio:', ticketData.servicio]);
        if (ticketData.proyecto) additionalData.push(['Proyecto:', ticketData.proyecto]);
        if (ticketData.ordenServicio) additionalData.push(['Orden de Servicio:', ticketData.ordenServicio]);
        if (ticketData.rfc) additionalData.push(['RFC:', ticketData.rfc]);
        if (ticketData.direccionFiscal) additionalData.push(['Dirección Fiscal:', ticketData.direccionFiscal]);
        if (ticketData.cuenta) additionalData.push(['Cuenta:', ticketData.cuenta]);

        if (additionalData.length > 0) {
            pdf.setFontSize(14);
            pdf.setFont('helvetica', 'bold');
            pdf.text('INFORMACIÓN ADICIONAL', 20, yPosition);
            yPosition += 10;
            
            yPosition = this.addTable(pdf, additionalData, yPosition, pageWidth);
            yPosition += 10;
        }

        return yPosition;
    }

    async addEvidenceSection(pdf, evidencia, yPosition, pageWidth, pageHeight) {
        // Verificar si necesitamos una nueva página
        if (yPosition > pageHeight - 50) {
            pdf.addPage();
            yPosition = 20;
        }

        // Título de evidencias del colaborador
        pdf.setFontSize(14);
        pdf.setFont('helvetica', 'bold');
        pdf.setTextColor(44, 62, 80);
        pdf.text(`EVIDENCIAS DE: ${evidencia.colaboradorNombre}`, 20, yPosition);
        yPosition += 10;

        // Descripción de la evidencia
        if (evidencia.descripcion) {
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'bold');
            pdf.text('Descripción del trabajo realizado:', 20, yPosition);
            yPosition += 8;

            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'normal');
            const splitDescription = pdf.splitTextToSize(evidencia.descripcion, pageWidth - 40);
            pdf.text(splitDescription, 20, yPosition);
            yPosition += splitDescription.length * 5 + 10;
        }

        // Imágenes de evidencia
        if (evidencia.imagenes && evidencia.imagenes.length > 0) {
            pdf.setFontSize(12);
            pdf.setFont('helvetica', 'bold');
            pdf.text(`Imágenes de evidencia (${evidencia.imagenes.length}):`, 20, yPosition);
            yPosition += 10;

            const imageWidth = 73; // 7.3 cm
            const imageHeight = 100; // 10 cm
            const imagesPerRow = 2;
            let imageCount = 0;

            for (const imageUrl of evidencia.imagenes) {
                try {
                    // Verificar si necesitamos una nueva página
                    if (yPosition + imageHeight > pageHeight - 20) {
                        pdf.addPage();
                        yPosition = 20;
                    }

                    const xPosition = 20 + (imageCount % imagesPerRow) * (imageWidth + 10);
                    
                    // Añadir imagen
                    await this.addImageToPDF(pdf, imageUrl, xPosition, yPosition, imageWidth, imageHeight);
                    
                    imageCount++;
                    
                    // Si completamos una fila, avanzar yPosition
                    if (imageCount % imagesPerRow === 0) {
                        yPosition += imageHeight + 10;
                    }
                } catch (error) {
                    console.error('Error añadiendo imagen:', error);
                }
            }

            // Si la última fila no está completa, avanzar yPosition
            if (imageCount % imagesPerRow !== 0) {
                yPosition += imageHeight + 10;
            }
        }

        return yPosition + 10;
    }

    async addImageToPDF(pdf, imageUrl, x, y, width, height) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = function() {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = width * 4; // Resolución más alta
                    canvas.height = height * 4;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const dataURL = canvas.toDataURL('image/jpeg', 0.8);
                    
                    pdf.addImage(dataURL, 'JPEG', x, y, width, height);
                    resolve();
                } catch (error) {
                    reject(error);
                }
            };
            
            img.onerror = () => reject(new Error('No se pudo cargar la imagen'));
            img.src = imageUrl;
        });
    }

    addTable(pdf, data, yPosition, pageWidth) {
        const rowHeight = 8;
        const colWidth = (pageWidth - 40) / 2;

        data.forEach(([label, value]) => {
            // Fondo alternativo para las filas
            pdf.setFillColor(248, 249, 250);
            pdf.rect(20, yPosition - 5, pageWidth - 40, rowHeight, 'F');
            
            // Texto del label
            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(44, 62, 80);
            pdf.text(label, 25, yPosition);
            
            // Texto del valor
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(0, 0, 0);
            const splitValue = pdf.splitTextToSize(value, colWidth - 10);
            pdf.text(splitValue, 25 + colWidth, yPosition);
            
            yPosition += Math.max(rowHeight, splitValue.length * 5);
        });

        return yPosition;
    }

    formatDate(timestamp) {
        if (!timestamp) return 'N/A';
        try {
            const date = timestamp.toDate();
            return date.toLocaleDateString('es-MX', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        } catch (error) {
            return 'Fecha inválida';
        }
    }

    async savePDFToFirebase(ticketId, pdfBase64) {
        try {
            const pdfData = {
                ticketId: ticketId,
                nombreArchivo: `Ticket_${ticketId.substring(0, 8)}_${new Date().toISOString().split('T')[0]}.pdf`,
                fechaCreacion: serverTimestamp(),
                colaboradorId: AppState.userData.colaboradorId,
                colaboradorNombre: AppState.userData.NOMBRE,
                contenido: pdfBase64,
                tamaño: Math.round(pdfBase64.length * 0.75) // Aproximar tamaño
            };

            await addDoc(collection(db, 'pdfMesa'), pdfData);
            console.log('PDF guardado en Firebase exitosamente');
        } catch (error) {
            console.error('Error guardando PDF en Firebase:', error);
            throw error;
        }
    }

    showProgressModal() {
        document.getElementById('pdfProgressModal').style.display = 'block';
    }

    hideProgressModal() {
        document.getElementById('pdfProgressModal').style.display = 'none';
    }

    updateProgress(percentage, text) {
        const progressFill = document.getElementById('pdfProgressFill');
        const progressText = document.getElementById('pdfProgressText');
        
        if (progressFill) progressFill.style.width = percentage + '%';
        if (progressText) progressText.textContent = Math.round(percentage) + '%';
        
        // Actualizar texto de progreso si se proporciona
        const progressTextElement = document.querySelector('#pdfProgressModal .modal-body p');
        if (progressTextElement && text) {
            progressTextElement.textContent = text;
        }
    }
}

// Instancia del generador de PDF
// Funciones de utilidad
const Utils = {
    showLoading: (message = 'Cargando...') => {
        Swal.fire({
            title: message,
            allowOutsideClick: false,
            didOpen: () => Swal.showLoading()
        });
    },
    
    hideLoading: () => Swal.close(),
    
    showError: (message, title = 'Error') => {
        Swal.fire({
            icon: 'error',
            title: title,
            text: message,
            confirmButtonColor: '#3085d6'
        });
    },
    
    formatDate: (timestamp) => {
        if (!timestamp) return 'N/A';
        try {
            const date = timestamp.toDate();
            return date.toLocaleDateString('es-MX', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        } catch (error) {
            console.error("Error formateando fecha:", error);
            return 'Fecha inválida';
        }
    },
    
   getBadgeClass: (status) => {
    switch(status) {
        case 'finalizado': 
        case 'completado': 
        case 'cerrado': 
            return 'badge-success';
        case 'en_proceso': 
        case 'en_camino': 
            return 'badge-warning';
        case 'pendiente': 
        case 'pendiente_de_aceptación': 
            return 'badge-danger';
        case 'aceptado': 
            return 'badge-info';
        default: 
            return 'badge-info';
    }
},
    
   getStatusIcon: (status) => {
    switch(status) {
        case 'finalizado': 
        case 'completado': 
        case 'cerrado': 
            return 'fa-check-circle';
        case 'en_proceso': 
            return 'fa-spinner';
        case 'en_camino': 
            return 'fa-truck';
        case 'pendiente': 
        case 'pendiente_de_aceptación': 
            return 'fa-clock';
        case 'aceptado': 
            return 'fa-check';
        default: 
            return 'fa-question-circle';
    }
},
    
    getPriorityClass: (priority) => {
        switch(priority) {
            case 'alta': return 'priority-high';
            case 'media': return 'priority-medium';
            case 'baja': return 'priority-low';
            default: return 'priority-medium';
        }
    },
    
    updateStatusChart: (pending, inProgress, completed) => {
        try {
            const maxValue = Math.max(pending, inProgress, completed, 1);
            DOM.statusChart.innerHTML = `
                <div class="chart-bar">
                    <div class="bar bar-pendiente" style="height: ${(pending / maxValue) * 80}px;" data-value="${pending}"></div>
                    <div class="bar-label">Pendientes</div>
                </div>
                <div class="chart-bar">
                    <div class="bar bar-proceso" style="height: ${(inProgress / maxValue) * 80}px;" data-value="${inProgress}"></div>
                    <div class="bar-label">En Proceso</div>
                </div>
                <div class="chart-bar">
                    <div class="bar bar-finalizado" style="height: ${(completed / maxValue) * 80}px;" data-value="${completed}"></div>
                    <div class="bar-label">Finalizados</div>
                </div>
            `;
        } catch (error) {
            console.error("Error actualizando gráfico de estado:", error);
        }
    },
    
    async showNotification(title, body, ticketId) {
        try {
            if (!('Notification' in window)) {
                console.log("Notificaciones no soportadas");
                return false;
            }

            const permission = await Notification.requestPermission();
            
            if (permission === 'granted') {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.ready;
                        
                        await registration.showNotification(title, {
                            body: body,
                            icon: 'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png',
                            badge: 'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png',
                            data: { 
                                url: `https://rsienterprise.web.app/?ticketId=${ticketId}`,
                                ticketId: ticketId
                            },
                            vibrate: [200, 100, 200],
                            actions: [
                                { 
                                    action: 'view', 
                                    title: 'Ver Ticket',
                                    icon: 'https://rsienterprise.web.app/vista/css/img/icon-eye.png'
                                }
                            ]
                        });
                        return true;
                    } catch (error) {
                        console.error("Error con Service Worker:", error);
                        // Fallback a notificación estándar
                        new Notification(title, {
                            body: body,
                            icon: 'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png'
                        });
                        return true;
                    }
                } else {
                    // Notificación estándar si no hay service worker
                    new Notification(title, {
                        body: body,
                        icon: 'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png'
                    });
                    return true;
                }
            }
            return false;
        } catch (error) {
            console.error("Error mostrando notificación:", error);
            return false;
        }
    }
};

// Controlador de Tickets - CORREGIDO
const TicketsController = {
    processTickets: (querySnapshot) => {
        const tickets = [];
        querySnapshot.forEach((doc) => {
            try {
                const data = doc.data();
                tickets.push({
                    id: doc.id,
                    ...data,
                    fechaCreacion: data.fechaCreacion,
                    fechaActualizacion: data.fechaActualizacion || null
                });
            } catch (error) {
                console.error("Error procesando ticket:", error);
            }
        });
        return tickets;
    },

    filterTickets: (tickets, showFinalized) => {
        if (showFinalized) {
            return tickets.filter(ticket => ticket.estado === 'finalizado');
        } else {
            return tickets.filter(ticket => ticket.estado !== 'finalizado');
        }
    },

    renderTickets: (tickets) => {
        try {
            // CAMBIO CLAVE: Usar TicketsController en lugar de this
            const filteredTickets = TicketsController.filterTickets(tickets, ticketManager.showFinalized);
            DOM.ticketsContainer.innerHTML = '';
            
            if (!filteredTickets || filteredTickets.length === 0) {
                const message = ticketManager.showFinalized 
                    ? 'No tienes tickets finalizados'
                    : 'No tienes tickets pendientes o en proceso';
                    
                DOM.ticketsContainer.innerHTML = `
                    <div class="no-tickets">
                        <i class="fas fa-ticket-alt"></i>
                        <h3>${message}</h3>
                        <p>Cuando ${ticketManager.showFinalized ? 'finalices' : 'te asignen'} tickets, aparecerán aquí</p>
                    </div>
                `;
                return;
            }

            // Calcular estadísticas para todos los tickets
            let pendingTickets = 0;
            let inProgressTickets = 0;
            let completedTickets = 0;
            let highPriority = 0;
            let mediumPriority = 0;
            let lowPriority = 0;

            tickets.forEach(ticket => {
                // Actualizar contadores de estado
                if (ticket.estado === 'pendiente') pendingTickets++;
                else if (ticket.estado === 'en_proceso') inProgressTickets++;
                else if (ticket.estado === 'finalizado') completedTickets++;
                
                // Actualizar contadores de prioridad
                if (ticket.prioridad === 'alta') highPriority++;
                else if (ticket.prioridad === 'media') mediumPriority++;
                else if (ticket.prioridad === 'baja') lowPriority++;
            });

            let html = '';
            filteredTickets.forEach(ticket => {
                try {
                    // Validaciones robustas
                    const ticketId = ticket.id || 'ID-NO-DISPONIBLE';
                    const shortId = ticketId.substring(0, 8);
                    const estado = ticket.estado || 'desconocido';
                    const titulo = ticket.titulo || 'Sin título';
                    const descripcion = ticket.descripcionActividades || 'Sin descripción';
                    const prioridad = ticket.prioridad || 'media';
                    const area = ticket.area || 'General';
                    const fechaCreacion = ticket.fechaCreacion || null;
                    
                    // Información del colaborador (si existe)
                    const colaboradorInfo = ticket.colaborador ? `
                        <div class="ticket-meta">
                            <span class="badge badge-primary">
                                <i class="fas fa-user"></i> ${ticket.colaborador.nombre || 'Sin nombre'}
                            </span>
                            <span class="badge badge-primary">
                                <i class="fas fa-briefcase"></i> ${ticket.colaborador.puesto || 'Sin puesto'}
                            </span>
                        </div>
                    ` : '';
                    
                    html += `
                        <div class="ticket-card">
                            <div class="ticket-header">
                                <span class="ticket-id">#${shortId.toUpperCase()}</span>
                                <span class="badge ${Utils.getBadgeClass(estado)}">
                                    <i class="fas ${Utils.getStatusIcon(estado)}"></i> ${estado.replace('_', ' ')}
                                </span>
                            </div>
                            <h3 class="ticket-title">${titulo}</h3>
                            <p class="ticket-desc">${descripcion.substring(0, 120)}${descripcion.length > 120 ? '...' : ''}</p>
                            
                            <div class="ticket-meta">
                                <span class="badge badge-primary">
                                    <span class="priority-indicator ${Utils.getPriorityClass(prioridad)}"></span>
                                    ${prioridad}
                                </span>
                                <span class="badge badge-primary">
                                    <i class="fas fa-layer-group"></i> ${area}
                                </span>
                            </div>
                            
                            ${colaboradorInfo}
                            
                            <div class="ticket-date">
                                <i class="fas fa-calendar-alt"></i> ${Utils.formatDate(fechaCreacion)}
                            </div>
                            
                            <button class="action-btn view" data-id="${ticketId}">
                                <i class="fas fa-eye"></i> Ver detalles
                            </button>
                        </div>
                    `;
                } catch (error) {
                    console.error("Error renderizando ticket:", error);
                }
            });
            
            // Actualizar estadísticas
            DOM.totalTickets.textContent = tickets.length;
            DOM.highPriority.textContent = highPriority;
            DOM.mediumPriority.textContent = mediumPriority;
            DOM.lowPriority.textContent = lowPriority;
            Utils.updateStatusChart(pendingTickets, inProgressTickets, completedTickets);
            
            DOM.ticketsContainer.innerHTML = html;
            
            // Agregar event listeners para los botones de ver detalles
            document.querySelectorAll('.action-btn.view').forEach(btn => {
                btn.addEventListener('click', () => TicketsController.showTicketDetails(btn.dataset.id));
            });
        } catch (error) {
            console.error("Error renderizando tickets:", error);
            Utils.showError("Error al mostrar los tickets");
        }
    },

    async loadUserTickets() {
        try {
            Utils.showLoading('Cargando tickets...');
            
            // Verificar que tenemos los datos del usuario
            if (!AppState.userData || !AppState.userData.nombreCompleto) {
                throw new Error('Datos de usuario incompletos');
            }
            
            const ticketsRef = collection(db, 'ticketsmesa');
            const nombreResponsable = AppState.userData.nombreCompleto;
            const colaboradorId = AppState.userData.colaboradorId;
            
            console.log("Buscando tickets para:", nombreResponsable, "o colaborador ID:", colaboradorId);
            
            let querySnapshot;
            try {
                // Ejecutar ambas consultas
                const qResponsable = query(
                    ticketsRef,
                    where("responsableNombre", "==", nombreResponsable),
                    orderBy("fechaCreacion", "desc")
                );
                
                const qColaborador = query(
                    ticketsRef,
                    where("colaboradores", "array-contains", colaboradorId),
                    orderBy("fechaCreacion", "desc")
                );
                
                const [snapshotResponsable, snapshotColaborador] = await Promise.all([
                    getDocs(qResponsable),
                    getDocs(qColaborador)
                ]);
                
                // Combinar resultados evitando duplicados
                const allTickets = new Map();
                
                snapshotResponsable.forEach(doc => {
                    allTickets.set(doc.id, doc);
                });
                
                snapshotColaborador.forEach(doc => {
                    allTickets.set(doc.id, doc);
                });
                
                querySnapshot = {
                    docs: Array.from(allTickets.values()),
                    empty: allTickets.size === 0,
                    size: allTickets.size,
                    forEach: function(callback) {
                        this.docs.forEach(doc => callback(doc));
                    }
                };
                
            } catch (error) {
                if (error.code === 'failed-precondition') {
                    console.warn("Índice faltante, cargando tickets sin ordenar...");
                    // Intentar sin ordenar
                    const qResponsable = query(
                        ticketsRef,
                        where("responsableNombre", "==", nombreResponsable)
                    );
                    
                    const qColaborador = query(
                        ticketsRef,
                        where("colaboradores", "array-contains", colaboradorId)
                    );
                    
                    const [snapshotResponsable, snapshotColaborador] = await Promise.all([
                        getDocs(qResponsable),
                        getDocs(qColaborador)
                    ]);
                    
                    // Combinar resultados
                    const allTickets = new Map();
                    
                    snapshotResponsable.forEach(doc => {
                        allTickets.set(doc.id, doc);
                    });
                    
                    snapshotColaborador.forEach(doc => {
                        allTickets.set(doc.id, doc);
                    });
                    
                    querySnapshot = {
                        docs: Array.from(allTickets.values()),
                        empty: allTickets.size === 0,
                        size: allTickets.size,
                        forEach: function(callback) {
                            this.docs.forEach(doc => callback(doc));
                        }
                    };
                } else {
                    throw error;
                }
            }
            
            console.log("Tickets encontrados:", querySnapshot.size);
            
            const tickets = this.processTickets(querySnapshot);
            const ticketsEnriquecidos = await this.enriquecerTicketsConColaborador(tickets);
            
            // Guardar todos los tickets en el estado global
            AppState.allTickets = ticketsEnriquecidos;
            
            this.renderTickets(ticketsEnriquecidos);
            
            // Verificar si hay tickets nuevos para notificar
            if (tickets.length > 0) {
                const latestTicketId = tickets[0].id;
                if (AppState.lastCheckedTicketId !== latestTicketId) {
                    AppState.lastCheckedTicketId = latestTicketId;
                }
            }
            
        } catch (error) {
            console.error("Error cargando tickets:", error);
            Utils.showError("No se pudieron cargar los tickets");
            DOM.ticketsContainer.innerHTML = `
                <div class="no-tickets">
                    <i class="fas fa-exclamation-triangle"></i>
                    <h3>Error al cargar tickets</h3>
                    <p>No se pudieron cargar los tickets. Intenta nuevamente.</p>
                </div>
            `;
        } finally {
            Utils.hideLoading();
        }
    },

    async enriquecerTicketsConColaborador(tickets) {
        if (!tickets || tickets.length === 0) return tickets;
        
        try {
            // Obtener datos del colaborador responsable
            const colaboradorRef = doc(db, 'colaboradores', AppState.userData.colaboradorId);
            const colaboradorSnap = await getDoc(colaboradorRef);
            
            if (!colaboradorSnap.exists()) {
                console.warn("No se encontró el documento del colaborador");
                return tickets;
            }
            
            const datosColaborador = colaboradorSnap.data();
            console.log("Datos del colaborador:", datosColaborador);
            
            // Añadir datos del colaborador a cada ticket
            return tickets.map(ticket => ({
                ...ticket,
                colaborador: {
                    nombre: datosColaborador.NOMBRE,
                    area: datosColaborador.ÁREA,
                    puesto: datosColaborador.PUESTO,
                    imagen: datosColaborador.imagen || null
                }
            }));
            
        } catch (error) {
            console.error("Error enriqueciendo tickets:", error);
            return tickets;
        }
    },

    async showFinishModal(ticketId, isEdit = false) {
        const modalTitle = document.getElementById('finishModalTitle');
        const descriptionField = document.getElementById('projectDescription');
        
        ticketManager.setCurrentTicket(ticketId, isEdit ? 'finalizado' : null);
        
        if (isEdit) {
            modalTitle.textContent = 'Modificar Finalización';
            
            // Obtener la evidencia existente del usuario para este ticket
            const evidenciasRef = collection(db, 'evidenciatickets');
            const q = query(
                evidenciasRef, 
                where("ticketId", "==", ticketId),
                where("colaboradorId", "==", AppState.userData.colaboradorId)
            );
            const querySnapshot = await getDocs(q);
            
            if (!querySnapshot.empty) {
                const evidencia = querySnapshot.docs[0].data();
                descriptionField.value = evidencia.descripcion || '';
                document.getElementById('charCount').textContent = evidencia.descripcion?.length || 0;
                ticketManager.setExistingImages(evidencia.imagenes || []);
                updateImagePreviews();
            }
        } else {
            modalTitle.textContent = 'Finalizar Ticket';
            descriptionField.value = '';
            document.getElementById('charCount').textContent = '0';
            ticketManager.setExistingImages([]);
            updateImagePreviews();
        }
        
        document.getElementById('imageUpload').value = '';
        document.getElementById('finishModal').style.display = 'block';
    },

    async showTicketDetails(ticketId) {
        try {
            Utils.showLoading('Cargando detalles...');
            
            const ticketRef = doc(db, 'ticketsmesa', ticketId);
            const ticketSnap = await getDoc(ticketRef);
            
            if (!ticketSnap.exists()) {
                throw new Error('El ticket no existe');
            }
            
            const data = ticketSnap.data();
            const shortId = ticketId.substring(0, 8);
            // Actualizar el estado en ticketManager
            ticketManager.setCurrentTicket(ticketId, data.estado);
            
            // Obtener nombres de colaboradores
            let nombresColaboradores = [];
            if (data.colaboradores && data.colaboradores.length > 0) {
                const colaboradoresPromises = data.colaboradores.map(async colabId => {
                    const colabRef = doc(db, 'colaboradores', colabId);
                    const colabSnap = await getDoc(colabRef);
                    return colabSnap.exists() ? colabSnap.data().NOMBRE : 'Colaborador desconocido';
                });
                nombresColaboradores = await Promise.all(colaboradoresPromises);
            }
            
            // Obtener todas las evidencias para este ticket
            const evidenciasRef = collection(db, 'evidenciatickets');
            const q = query(evidenciasRef, where("ticketId", "==", ticketId));
            const evidenciasSnap = await getDocs(q);
            
            const evidencias = [];
            evidenciasSnap.forEach(doc => {
                evidencias.push(doc.data());
            });
            
            // Configurar botones según si el usuario ya subió evidencias
            const finishBtn = document.getElementById('finishTicketBtn');
            const editBtn = document.getElementById('editFinishBtn');
            
            // Definir userEvidence aquí antes de usarla
            const userEvidence = evidencias.find(
                ev => ev.colaboradorId === AppState.userData.colaboradorId
            );
            
            // Configurar botones
            const ticketEstaFinalizado = data.estado === 'finalizado';
            const usuarioYaCompleto = !!userEvidence;

            if (ticketEstaFinalizado) {
                finishBtn.style.display = 'none';
                editBtn.style.display = 'none';
            } else if (usuarioYaCompleto) {
                finishBtn.style.display = 'none';
                editBtn.style.display = 'inline-flex';
            } else {
                finishBtn.style.display = 'inline-flex';
                editBtn.style.display = 'none';
            }
            
            // Mostrar detalles del ticket
            const modal = document.getElementById('detailModal');
            const detailContent = document.getElementById('detailContent');
            
            // Crear HTML para el progreso de colaboradores
            let progressHTML = '';
            if (data.colaboradores && data.colaboradores.length > 1) {
                progressHTML = `
                    <div class="detail-section">
                        <strong>Progreso de Colaboradores</strong>
                        <div class="progress-container">
                            ${data.colaboradores.map((colabId, index) => {
                                const evidenciaColab = evidencias.find(ev => ev.colaboradorId === colabId);
                                const completado = !!evidenciaColab;
                                const nombreColab = nombresColaboradores[index] || 'Colaborador';
                                
                                return `
                                    <div class="progress-item">
                                        <span class="progress-name">${nombreColab}</span>
                                        <span class="progress-status ${completado ? 'completed' : 'pending'}">
                                            <i class="fas ${completado ? 'fa-check-circle' : 'fa-clock'}"></i>
                                            ${completado ? 'Completado' : 'Pendiente'}
                                        </span>
                                        ${completado ? `
                                            <button class="view-evidence-btn" data-colab-id="${colabId}">
                                                <i class="fas fa-eye"></i>
                                            </button>
                                            
                                        ` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Crear HTML para las imágenes del usuario actual si existen
            let userEvidenceHTML = '';
            if (userEvidence) {
                userEvidenceHTML = `
                    <div class="detail-section">
                        <strong>Mis Evidencias</strong>
                        <div class="description-text">${userEvidence.descripcion}</div>
                        <div class="evidence-grid">
                            ${userEvidence.imagenes.map(img => `
                                <img src="${img}" class="evidence-img clickable-image" 
                                     alt="Mi evidencia" style="cursor: pointer; max-height: 150px;"
                                     onclick="openImageModal('${img}')">
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            // Crear HTML para información adicional del ticket
            let additionalInfoHTML = '';
            if (data.servicio || data.proyecto || data.ordenServicio || data.descripcionActividades) {
                additionalInfoHTML = `
                    <div class="detail-section">
                        <strong>Información Adicional</strong>
                        ${data.servicio ? `<p><span class="detail-label">Servicio:</span> ${data.servicio}</p>` : ''}
                        ${data.proyecto ? `<p><span class="detail-label">Proyecto:</span> ${data.proyecto}</p>` : ''}
                        ${data.ordenServicio ? `<p><span class="detail-label">Orden de Servicio:</span> ${data.ordenServicio}</p>` : ''}
                        ${data.descripcionActividades ? `<p><span class="detail-label">Actividades:</span> ${data.descripcionActividades}</p>` : ''}
                    </div>
                `;
            }
            
            // Crear HTML para información fiscal si existe
            let fiscalInfoHTML = '';
            if (data.rfc || data.direccionFiscal || data.cuenta) {
                fiscalInfoHTML = `
                    <div class="detail-section">
                        <strong>Información Fiscal</strong>
                        ${data.rfc ? `<p><span class="detail-label">RFC:</span> ${data.rfc}</p>` : ''}
                        ${data.direccionFiscal ? `<p><span class="detail-label">Dirección Fiscal:</span> ${data.direccionFiscal}</p>` : ''}
                        ${data.cuenta ? `<p><span class="detail-label">Cuenta:</span> ${data.cuenta}</p>` : ''}
                    </div>
                `;
            }
            
            // Crear HTML para sistemas si existen
            let sistemasHTML = '';
            if (data.sistemas && Object.keys(data.sistemas).length > 0) {
                sistemasHTML = `
                    <div class="detail-section">
                        <strong>Sistemas Relacionados</strong>
                        <ul>
                            ${Object.entries(data.sistemas).map(([key, value]) => `
                                <li>${key}: ${value}</li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            }
            
            detailContent.innerHTML = `
                <div style="text-align: left;">
                    <div class="detail-section">
                        <strong>Información Básica</strong>
                        <p><span class="detail-label">ID:</span> #${shortId.toUpperCase()}</p>
                        <p><span class="detail-label">Título:</span> ${data.titulo}</p>
                        <p><span class="detail-label">Estado:</span> 
                            <span class="badge ${Utils.getBadgeClass(data.estado)}">
                                <i class="fas ${Utils.getStatusIcon(data.estado)}"></i> ${data.estado.replace('_', ' ')}
                            </span>
                        </p>
                        <p><span class="detail-label">Prioridad:</span> 
                            <span class="badge badge-primary">
                                <span class="priority-indicator ${Utils.getPriorityClass(data.prioridad)}"></span> 
                                ${data.prioridad}
                            </span>
                        </p>
                        <p><span class="detail-label">Área:</span> 
                            <span class="badge badge-primary">
                                <i class="fas fa-layer-group"></i> ${data.area || 'General'}
                            </span>
                        </p>
                        <p><span class="detail-label">Responsable:</span> ${data.responsableNombre}</p>
                        <p><span class="detail-label">Colaboradores:</span> ${nombresColaboradores.join(', ')}</p>
                        <p><span class="detail-label">Fecha creación:</span> ${Utils.formatDate(data.fechaCreacion)}</p>
                        ${data.fechaActualizacion ? `<p><span class="detail-label">Última actualización:</span> ${Utils.formatDate(data.fechaActualizacion)}</p>` : ''}
                        ${data.fechaFinalizacion ? `<p><span class="detail-label">Fecha finalización:</span> ${Utils.formatDate(data.fechaFinalizacion)}</p>` : ''}
                    </div>
                    
                    ${progressHTML}
                    
                    <div class="detail-section">
                        <strong>Descripción</strong>
                        <div class="description-text">${data.descripcionActividades}</div>
                    </div>
                    
                    ${additionalInfoHTML}
                    ${fiscalInfoHTML}
                    ${sistemasHTML}
                    ${userEvidenceHTML}
                </div>
            `;
            
   // Configurar event listeners para los botones de evidencias
document.querySelectorAll('.view-evidence-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const colabId = btn.dataset.colabId;
        const evidencia = evidencias.find(ev => ev.colaboradorId === colabId);
        if (evidencia) {
            Swal.fire({
                title: `Evidencias de ${evidencia.colaboradorNombre}`,
                html: `
                    <div style="text-align: left; margin-bottom: 20px;">
                        <p><strong>Descripción:</strong></p>
                        <div class="description-text">${evidencia.descripcion}</div>
                    </div>
                    <div class="evidence-grid">
                        ${evidencia.imagenes.map(img => `
                            <img src="${img}" class="evidence-img clickable-image" 
                                 alt="Evidencia" style="cursor: pointer; max-height: 300px;"  // <-- CAMBIO AQUÍ
                                 onclick="openImageModal('${img}')">
                        `).join('')}
                    </div>
                `,
                width: '80%',
                confirmButtonText: 'Cerrar',
                
                // --- Tus cambios para el modo oscuro ---
                background: '#1e1e1e', // Fondo oscuro (casi negro)
                color: '#ffffff'       // Texto en color blanco para que sea legible
                // --- FIN DE CAMBIOS ---
            });
        }
    });
});

// No olvides que necesitas la función openImageModal para verlas en tamaño completo
function openImageModal(imgSrc) {
    Swal.fire({
        imageUrl: imgSrc,
        imageAlt: 'Evidencia en tamaño completo',
        background: '#1e1e1e',
        padding: '1em',
        showConfirmButton: false,
        width: 'auto',
    });
}

            // Configurar event listeners para los botones de PDF
            document.querySelectorAll('.print-pdf-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const ticketId = btn.dataset.ticketId;
                    await this.generateTicketPDF(ticketId);
                });
            });
            
            modal.style.display = 'block';
            
        } catch (error) {
            console.error("Error mostrando detalles:", error);
            Utils.showError("No se pudieron cargar los detalles del ticket");
        } finally {
            Utils.hideLoading();
        }
    },

    async generateTicketPDF(ticketId) {
        try {
            // Obtener datos del ticket
            const ticketRef = doc(db, 'ticketsmesa', ticketId);
            const ticketSnap = await getDoc(ticketRef);
            
            if (!ticketSnap.exists()) {
                throw new Error('El ticket no existe');
            }
            
            const ticketData = { id: ticketId, ...ticketSnap.data() };
            
            // Obtener evidencias
            const evidenciasRef = collection(db, 'evidenciatickets');
            const q = query(evidenciasRef, where("ticketId", "==", ticketId));
            const evidenciasSnap = await getDocs(q);
            
            const evidencias = [];
            evidenciasSnap.forEach(doc => {
                evidencias.push(doc.data());
            });
            
            // Generar PDF
            await pdfGenerator.generateTicketPDF(ticketData, evidencias);
            
        } catch (error) {
            console.error('Error generando PDF:', error);
            Utils.showError('No se pudo generar el PDF: ' + error.message);
        }
    },

    async checkForNewTickets() {
        try {
            if (!AppState.userData || !AppState.userData.nombreCompleto) return false;
            
            const ticketsRef = collection(db, 'ticketsmesa');
            const q = query(
                ticketsRef,
                where("responsableNombre", "==", AppState.userData.nombreCompleto),
                where("notificacion", "==", false), // Solo tickets no notificados
                orderBy("fechaCreacion", "desc"),
                limit(1)
            );
            
            const querySnapshot = await getDocs(q);
            
            if (!querySnapshot.empty) {
                const latestTicket = querySnapshot.docs[0];
                const ticketId = latestTicket.id;
                const ticketRef = doc(db, 'ticketsmesa', ticketId);
                const ticketData = latestTicket.data();
                
                // Mostrar notificación
                const notificationShown = await Utils.showNotification(
                    'Nuevo Ticket Asignado - RSI',
                    `Tienes un nuevo ticket: "${ticketData.titulo || 'Nuevo ticket sin título'}"`,
                    ticketId
                );
                
                if (notificationShown) {
                    // Actualizar el campo notificacion a true solo si se mostró la notificación
                    await updateDoc(ticketRef, {
                        notificacion: true
                    });
                    
                    // Actualizar el último ticket verificado
                    AppState.lastCheckedTicketId = ticketId;
                    
                    // Recargar los tickets para reflejar el cambio
                    await this.loadUserTickets();
                    
                    return true;
                }
            }
            return false;
        } catch (error) {
            console.error("Error verificando nuevos tickets:", error);
            return false;
        }
    }
};

const AssistanceController = {
    async endAssistance() {
        try {
            // Verificar si ya se está procesando
            if (this._isEndingAssistance) return;
            this._isEndingAssistance = true;
            
            Utils.showLoading('Registrando fin de asistencia...');
            
            if (!AppState.currentUser || !AppState.userData || !AppState.userData.colaboradorId) {
                throw new Error('No se encontraron los datos del usuario');
            }
            
            // Obtener referencia al colaborador
            const colaboradorRef = doc(db, 'colaboradores', AppState.userData.colaboradorId);
            const colaboradorSnap = await getDoc(colaboradorRef);
            
            if (!colaboradorSnap.exists()) {
                throw new Error('No se encontró el registro del colaborador');
            }
            
            const colaboradorData = colaboradorSnap.data();
            
            // Verificar si la asistencia ya está cerrada
            if (!colaboradorData.asistencia?.estado) {
                throw new Error('Tu asistencia ya está cerrada');
            }
            
            // Actualizar el estado de asistencia
            await updateDoc(colaboradorRef, {
                'asistencia.estado': false,
                'asistencia.ultimoCierre': serverTimestamp()
            });
            
            // Registrar en la colección de asistencia
            const asistenciaRef = collection(db, 'asistencias');
            await addDoc(asistenciaRef, {
                colaboradorId: AppState.userData.colaboradorId,
                colaboradorNombre: AppState.userData.NOMBRE,
                tipo: 'salida',
                fecha: serverTimestamp(),
                area: AppState.userData.ÁREA,
                email: AppState.currentUser.email,
                dia: new Date().toLocaleDateString('es-MX', { weekday: 'long' }),
                horaRegistro: new Date().toLocaleTimeString('es-MX'),
                ubicacion: {
                    latitude: 19.4372,
                    longitude: -99.0369,
                    accuracy: 5000,
                    source: 'lp'
                }
            });
            
            Utils.hideLoading();
            
            // Mostrar confirmación y redirigir
            await Swal.fire({
                icon: 'success',
                title: 'Asistencia registrada',
                text: 'Se ha registrado correctamente tu salida. Serás redirigido.',
                confirmButtonColor: '#3085d6',
                allowOutsideClick: false,
                timer: 3000,
                timerProgressBar: true
            });
            
            // Redirigir igual que en el logout
            await AuthController.signOut();
            
        } catch (error) {
            console.error("Error terminando asistencia:", error);
            
            let errorMessage = error.message;
            if (errorMessage.includes('asistencia ya está cerrada')) {
                // Si ya estaba cerrada, forzar logout igualmente
                await AuthController.signOut();
                return;
            }
            
            Utils.showError(errorMessage || 'No se pudo registrar la asistencia');
        } finally {
            this._isEndingAssistance = false;
            Utils.hideLoading();
        }
    }
};

// Controlador de autenticación
const AuthController = {
    async signInWithGoogle() {
        try {
            Utils.showLoading('Iniciando sesión...');
            const result = await signInWithPopup(auth, provider);
            AppState.currentUser = result.user;
            console.log('Usuario autenticado:', result.user);
            await this.verifyUserAccess(AppState.currentUser.email);
        } catch (error) {
            console.error("Error al iniciar sesión:", error);
            Utils.showError(error.message || 'No se pudo iniciar sesión');
        }
    },
    
    async verifyUserAccess(email) {
        try {
            Utils.showLoading('Verificando acceso...');
            
            console.log('Verificando acceso para:', email);
            
            // 1. Verificar en la colección 'usuarios'
            const usuariosRef = collection(db, 'usuarios');
            const q = query(usuariosRef, where("email", "==", email));
            const userSnapshot = await getDocs(q);
            
            if (userSnapshot.empty) {
                throw new Error('No tienes acceso a esta plataforma');
            }
            
            // Obtener rol del usuario
            let userRole = null;
            userSnapshot.forEach(doc => {
                userRole = doc.data().rol;
                console.log('Rol del usuario:', userRole);
            });
            
            // Permitir acceso a todos excepto a los que tengan rol 'user'
            if (userRole === 'user') {
                throw new Error('No tienes permisos para acceder a esta sección');
            }
            
            AppState.userRole = userRole;
            
            // Mostrar botón de crear ticket solo para admincolaborador
            if (userRole === 'admincolaborador') {
                const createTicketBtn = document.getElementById('createTicketBtn');
                if (createTicketBtn) {
                    createTicketBtn.style.display = 'block';
                }
            }
            
            // 2. Obtener datos del colaborador
            const colaboradoresRef = collection(db, 'colaboradores');
            const q2 = query(colaboradoresRef, where("CORREO ELECTRÓNICO EMPRESARIAL", "==", email));
            const collabSnapshot = await getDocs(q2);
            
            if (collabSnapshot.empty) {
                throw new Error('No se encontraron tus datos de colaborador');
            }
            
            collabSnapshot.forEach(doc => {
                AppState.userData = doc.data();
                AppState.userData.colaboradorId = doc.id;
                AppState.userData.nombreCompleto = doc.data()['NOMBRE'];
                console.log("Datos del colaborador cargados:", AppState.userData);
            });
            
            // Actualizar UI
            this.updateUserProfile();
            
            // Cargar tickets del usuario
            await TicketsController.loadUserTickets();
            
            // Configurar intervalo para verificar nuevos tickets
            this.setupTicketCheckInterval();
            
        } catch (error) {
            console.error("Error verificando acceso:", error);
            await this.signOut();
            Utils.showError(error.message);
        } finally {
            Utils.hideLoading();
        }
    },
    
    updateUserProfile() {
        if (!AppState.userData) return;
        
        const userAvatar = DOM.userAvatar;
        const userNameDisplay = DOM.userNameDisplay;
        const userAreaDisplay = DOM.userAreaDisplay;
        
        if (userAvatar) {
            userAvatar.src = AppState.userData.imagen || 
                           'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png';
        }
        
        if (userNameDisplay && AppState.userData.NOMBRE) {
            userNameDisplay.textContent = AppState.userData.NOMBRE;
        }
        
        if (userAreaDisplay && AppState.userData.ÁREA) {
            userAreaDisplay.textContent = `ÁREA: ${AppState.userData.ÁREA}`;
        }
    },
    
    async signOut() {
        try {
            // Evitar múltiples ejecuciones
            if (this._isLoggingOut) return;
            this._isLoggingOut = true;
            
            Utils.showLoading('Cerrando sesión...');
            await signOut(auth);
            
            // Limpiar estado
            AppState.currentUser = null;
            AppState.userData = null;
            AppState.userRole = null;
            
            // Limpiar UI
            if (DOM.userAvatar) {
                DOM.userAvatar.src = 'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png';
            }
            if (DOM.userNameDisplay) {
                DOM.userNameDisplay.textContent = 'Usuario no autenticado';
            }
            if (DOM.userAreaDisplay) {
                DOM.userAreaDisplay.textContent = 'ÁREA: No disponible';
            }
            
            // Cerrar cualquier modal abierto
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => modal.style.display = 'none');
            
            // Redirección única con reemplazo en el historial
            window.location.replace('/vista/nav-visitantes/inicio-de-sesion.html');
            
        } catch (error) {
            console.error("Error al cerrar sesión:", error);
            Utils.showError('No se pudo cerrar la sesión correctamente');
        } finally {
            this._isLoggingOut = false;
            Utils.hideLoading();
        }
    },
    
    setupTicketCheckInterval() {
        // Limpiar intervalo anterior si existe
        if (AppState.ticketCheckInterval) {
            clearInterval(AppState.ticketCheckInterval);
        }
        
        // Configurar nuevo intervalo
        const checkTickets = async () => {
            const hadNewTickets = await TicketsController.checkForNewTickets();
            
            if (hadNewTickets) {
                // Si hubo notificaciones, aumentar el intervalo temporalmente
                clearInterval(AppState.ticketCheckInterval);
                AppState.notificationCheckInterval = 30000; // 30 segundos
                
                AppState.ticketCheckInterval = setInterval(checkTickets, AppState.notificationCheckInterval);
            } else {
                // Volver al intervalo normal si no hay notificaciones
                if (AppState.notificationCheckInterval !== 10000) {
                    clearInterval(AppState.ticketCheckInterval);
                    AppState.notificationCheckInterval = 10000; // 10 segundos
                    
                    AppState.ticketCheckInterval = setInterval(checkTickets, AppState.notificationCheckInterval);
                }
            }
        };
        
        // Iniciar el intervalo
        AppState.ticketCheckInterval = setInterval(checkTickets, AppState.notificationCheckInterval);
    },
    
    initializeAuthListener() {
        onAuthStateChanged(auth, async (user) => {
            console.log('Estado de autenticación cambió:', user ? 'Autenticado' : 'No autenticado');
            if (user) {
                AppState.currentUser = user;
                try {
                    await this.verifyUserAccess(user.email);
                } catch (error) {
                    console.error("Error en auth listener:", error);
                }
            } else {
                console.log('Usuario no autenticado, iniciando proceso de login...');
                this.signInWithGoogle();
            }
        });
    }
};

// Event Listeners
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM cargado, inicializando aplicación...');
    
    // Configurar evento de logout
    if (DOM.logoutBtn) {
        DOM.logoutBtn.addEventListener('click', () => {
            AuthController.signOut();
        });
    }

    // Configurar evento para el botón de terminar asistencia
    if (DOM.endAssistanceBtn) {
        DOM.endAssistanceBtn.addEventListener('click', async () => {
            await AssistanceController.endAssistance();
        });
    }

    // Configurar el filtro de tickets
    if (DOM.filterBtn) {
        DOM.filterBtn.addEventListener('click', () => {
            const showFinalized = ticketManager.toggleFilter();
            if (DOM.filterText) {
                DOM.filterText.textContent = showFinalized ? 'Ver Activos' : 'Ver Finalizados';
            }
            
            // Re-renderizar tickets con el nuevo filtro
            if (AppState.allTickets.length > 0) {
                TicketsController.renderTickets(AppState.allTickets);
            }
        });
    }

    
    // Configurar el botón de cerrar en el modal de detalles
// Configurar todos los botones de cerrar
const closeButtons = document.querySelectorAll('.modal .close, .cancel-btn, #closeDetailBtn');
closeButtons.forEach(btn => {
    btn.addEventListener('click', closeModals);
});
    
    
    // Event listener para el botón de crear ticket
    const createTicketBtn = document.getElementById('createTicketBtn');
    if (createTicketBtn) {
        createTicketBtn.addEventListener('click', () => {
            window.location.href = '/vista/nav-mesa/gestion-tickets.html';
        });
    }

    // Configurar el botón de finalizar ticket en el modal de detalles
    const finishTicketBtn = document.getElementById('finishTicketBtn');
    if (finishTicketBtn) {
        finishTicketBtn.addEventListener('click', async function() {
            const ticketId = ticketManager.currentTicketId;
            if (ticketId) {
                // Verificar el estado actual del ticket
                const ticketRef = doc(db, 'ticketsmesa', ticketId);
                const ticketSnap = await getDoc(ticketRef);
                
                if (ticketSnap.exists()) {
                    const ticketData = ticketSnap.data();
                    
                    if (ticketData.estado === 'finalizado') {
                        Swal.fire({
                            icon: 'error',
                            title: 'Ticket ya finalizado',
                            text: 'Este ticket ya ha sido marcado como finalizado',
                            confirmButtonColor: '#3085d6'
                        });
                        return;
                    }
                    
                    // Verificar si el usuario ya completó este ticket
                    const evidenciasRef = collection(db, 'evidenciatickets');
                    const q = query(
                        evidenciasRef, 
                        where("ticketId", "==", ticketId),
                        where("colaboradorId", "==", AppState.userData.colaboradorId)
                    );
                    const querySnapshot = await getDocs(q);
                    
                    if (!querySnapshot.empty) {
                        Swal.fire({
                            icon: 'error',
                            title: 'Ya completaste este ticket',
                            text: 'Ya has enviado evidencias para este ticket. Puedes modificarlas si es necesario.',
                            confirmButtonColor: '#3085d6'
                        });
                        return;
                    }
                    
                    await TicketsController.showFinishModal(ticketId, false);
                }
            }
        });
    }

    // Configurar el botón de editar finalización
    const editFinishBtn = document.getElementById('editFinishBtn');
    if (editFinishBtn) {
        editFinishBtn.addEventListener('click', async function() {
            const ticketId = ticketManager.currentTicketId;
            if (ticketId) {
                await TicketsController.showFinishModal(ticketId, true);
            }
        });
    }
    
    setupFinishModal();
        
    AuthController.initializeAuthListener();
    
    // Hacer Swal disponible globalmente
    window.Swal = Swal;

    // Registrar Service Worker
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('../../sw.js')
                .then(registration => {
                    console.log('ServiceWorker registrado:', registration.scope);
                    // Escuchar clics en notificaciones
                    navigator.serviceWorker.addEventListener('message', event => {
                        if (event.data && event.data.action === 'view') {
                            TicketsController.showTicketDetails(event.data.ticketId);
                        }
                    });
                })
                .catch(error => {
                    console.log('Error al registrar ServiceWorker:', error);
                });
        });
    }
});

function handleImageUpload(e) {
    const files = e.target.files;
    
    if (files.length > 10) {
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'Solo puedes subir hasta 10 imágenes',
            confirmButtonColor: '#3085d6'
        });
        e.target.value = '';
        return;
    }
    
    ticketManager.selectedImages = [];
    
    Array.from(files).forEach((file) => {
        if (!file.type.match('image.*')) return;
        
        compressImage(file, function(compressedBase64) {
            if (compressedBase64) {
                ticketManager.addSelectedImage(compressedBase64);
                updateImagePreviews();
            }
        });
    });
}

async function handleFinishFormSubmit(e) {
    e.preventDefault();
    
    const finishBtn = this.querySelector('button[type="submit"]');
    const originalText = finishBtn.innerHTML;
    finishBtn.disabled = true;
    finishBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Procesando...';
    
    try {
        const description = document.getElementById('projectDescription').value;
        const allImages = ticketManager.getAllImages();
        
        // Validaciones
        if (description.length < 10) {
            throw new Error('La descripción debe tener al menos 10 caracteres');
        }
        
        if (allImages.length === 0) {
            throw new Error('Debes subir al menos una imagen como evidencia');
        }
        
        Utils.showLoading('Guardando información...');
        
        // Crear documento de evidencia
        const evidenciaData = {
            ticketId: ticketManager.currentTicketId,
            colaboradorId: AppState.userData.colaboradorId,
            colaboradorNombre: AppState.userData.NOMBRE,
            descripcion: description,
            imagenes: allImages,
            fechaCreacion: serverTimestamp(),
            estado: 'completado'
        };
        
        // Guardar evidencia
        await addDoc(collection(db, 'evidenciatickets'), evidenciaData);
        
        // Actualizar estado del ticket
        const ticketRef = doc(db, 'ticketsmesa', ticketManager.currentTicketId);
        const ticketSnap = await getDoc(ticketRef);
        
        if (ticketSnap.exists()) {
            const ticketData = ticketSnap.data();
            const evidenciasCompletadas = ticketData.evidenciasCompletadas || [];
            
            if (!evidenciasCompletadas.includes(AppState.userData.colaboradorId)) {
                evidenciasCompletadas.push(AppState.userData.colaboradorId);
                
                const colaboradores = ticketData.colaboradores || [];
                const todosCompletados = colaboradores.every(colabId => 
                    evidenciasCompletadas.includes(colabId)
                );
                
                await updateDoc(ticketRef, {
                    evidenciasCompletadas,
                    estado: todosCompletados ? 'finalizado' : 'en_proceso',
                    todosCompletados,
                    fechaActualizacion: serverTimestamp(),
                    ...(todosCompletados && { fechaFinalizacion: serverTimestamp() })
                });

                // Si el ticket se completó, generar PDF automáticamente
                if (todosCompletados) {
                    try {
                        // Obtener todas las evidencias
                        const evidenciasRef = collection(db, 'evidenciatickets');
                        const q = query(evidenciasRef, where("ticketId", "==", ticketManager.currentTicketId));
                        const evidenciasSnap = await getDocs(q);
                        
                        const evidencias = [];
                        evidenciasSnap.forEach(doc => {
                            evidencias.push(doc.data());
                        });
                        
                        // Generar PDF
                        const completeTicketData = { id: ticketManager.currentTicketId, ...ticketData };
                        await pdfGenerator.generateTicketPDF(completeTicketData, evidencias);
                    } catch (pdfError) {
                        console.error('Error generando PDF automático:', pdfError);
                        // No mostrar error al usuario, solo loggear
                    }
                }
            }
        }
        
        // Cerrar modales y actualizar UI sin recargar
        closeModals();
        
        // Mostrar confirmación
        Swal.fire({
            icon: 'success',
            title: '¡Éxito!',
            text: 'Tus evidencias han sido guardadas correctamente',
            confirmButtonColor: '#3085d6'
        }).then(() => {
            // Actualizar la vista de detalles si está abierta
            if (document.getElementById('detailModal').style.display === 'block') {
                TicketsController.showTicketDetails(ticketManager.currentTicketId);
            }
            
            // Actualizar la lista de tickets
            TicketsController.loadUserTickets();
        });
        
    } catch (error) {
        console.error("Error guardando evidencias:", error);
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: error.message || 'No se pudieron guardar las evidencias',
            confirmButtonColor: '#3085d6'
        });
    } finally {
        finishBtn.disabled = false;
        finishBtn.innerHTML = originalText;
        Utils.hideLoading();
    }
}

// Modifica la función setupFinishModal para asegurar que los eventos se configuren correctamente
function setupFinishModal() {
    // Verificar que los elementos existen
    const textarea = document.getElementById('projectDescription');
    const counter = document.getElementById('charCount');
    const input = document.getElementById('imageUpload');
    const finishForm = document.getElementById('finishForm');
    
    if (!textarea || !counter || !input || !finishForm) {
        console.error('Elementos del modal no encontrados');
        return;
    }
    
    // Configurar eventos (solo una vez)
    textarea.addEventListener('input', function() {
        const remaining = 10000 - this.value.length;
        counter.textContent = this.value.length;
        
        if (remaining < 0) {
            this.value = this.value.substring(0, 10000);
            counter.textContent = '10000';
        }
    });
    
    input.addEventListener('change', handleImageUpload);
    
    finishForm.addEventListener('submit', handleFinishFormSubmit);
}

function updateImagePreviews() {
    const previewContainer = document.getElementById('imagePreviewContainer');
    if (!previewContainer) return;
    
    previewContainer.innerHTML = '';
    
    // Mostrar imágenes existentes primero
    ticketManager.existingImages.forEach((img, index) => {
        const imgPreview = document.createElement('div');
        imgPreview.className = 'image-preview-item';
        imgPreview.innerHTML = `
            <img src="${img}" alt="Preview" style="cursor: pointer;">
            <button class="delete-image-btn" data-index="${index}" data-existing="true">
                <i class="fas fa-trash"></i>
            </button>
        `;
        previewContainer.appendChild(imgPreview);
        
        // Configurar evento para ver la imagen en grande
        imgPreview.querySelector('img').addEventListener('click', function() {
            document.getElementById('expandedImage').src = img;
            document.getElementById('imageViewerModal').style.display = 'flex';
        });
        
        // Configurar botón para eliminar imagen existente
        imgPreview.querySelector('.delete-image-btn').addEventListener('click', function(e) {
            e.stopPropagation();
            const idx = parseInt(this.getAttribute('data-index'));
            ticketManager.removeExistingImage(idx);
            updateImagePreviews();
        });
    });
    
    // Mostrar imágenes seleccionadas nuevas
    ticketManager.selectedImages.forEach((img, index) => {
        const imgPreview = document.createElement('div');
        imgPreview.className = 'image-preview-item';
        imgPreview.innerHTML = `
            <img src="${img}" alt="Preview" style="cursor: pointer;">
            <button class="delete-image-btn" data-index="${index}" data-existing="false">
                <i class="fas fa-trash"></i>
            </button>
        `;
        previewContainer.appendChild(imgPreview);
        
        // Configurar evento para ver la imagen en grande
        imgPreview.querySelector('img').addEventListener('click', function() {
            document.getElementById('expandedImage').src = img;
            document.getElementById('imageViewerModal').style.display = 'flex';
        });
        
        // Configurar botón para eliminar imagen seleccionada
        imgPreview.querySelector('.delete-image-btn').addEventListener('click', function(e) {
            e.stopPropagation();
            const idx = parseInt(this.getAttribute('data-index'));
            ticketManager.removeSelectedImage(idx);
            updateImagePreviews();
        });
    });
}

// Comprimir imagen antes de convertir a base64
function compressImage(file, callback) {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    
    reader.onload = function(event) {
        const img = new Image();
        img.src = event.target.result;
        
        img.onload = function() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Tamaño máximo deseado
            const MAX_WIDTH = 800;
            const MAX_HEIGHT = 600;
            let width = img.width;
            let height = img.height;
            
            // Redimensionar si es necesario
            if (width > height) {
                if (width > MAX_WIDTH) {
                    height *= MAX_WIDTH / width;
                    width = MAX_WIDTH;
                }
            } else {
                if (height > MAX_HEIGHT) {
                    width *= MAX_HEIGHT / height;
                    height = MAX_HEIGHT;
                }
            }
            
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            
            // Convertir a base64 con calidad reducida
            const compressedBase64 = canvas.toDataURL('image/jpeg', 0.7);
            callback(compressedBase64);
        };
    };
}

function closeModals(e) {
    // Prevenir comportamiento por defecto si es un evento
    if (e) e.preventDefault();
    
    const modals = ['detailModal', 'finishModal', 'imageViewerModal', 'pdfProgressModal'];
    modals.forEach(modalId => {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'none';
        }
    });
    
    // Limpiar el formulario
    const finishForm = document.getElementById('finishForm');
    const charCount = document.getElementById('charCount');
    const imageUpload = document.getElementById('imageUpload');
    
    if (finishForm) finishForm.reset();
    if (charCount) charCount.textContent = '0';
    if (imageUpload) imageUpload.value = '';
    
    // Limpiar imágenes seleccionadas pero mantener existentes si estamos editando
    ticketManager.selectedImages = [];
    updateImagePreviews();
}

// Función para abrir el modal con la imagen en grande
window.openImageModal = function(imageSrc) {
    const modal = document.getElementById('imageViewerModal');
    const img = document.getElementById('expandedImage');
    if (modal && img) {
        img.src = imageSrc;
        modal.style.display = 'block';
    }
};

// Función para cerrar el modal de imagen
function closeImageModal() {
    const modal = document.getElementById('imageViewerModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Configurar el evento de clic para cerrar el modal de imagen
const imageModalClose = document.querySelector('#imageViewerModal .close');
if (imageModalClose) {
    imageModalClose.addEventListener('click', closeImageModal);
}

// Cerrar al hacer clic fuera de la imagen
const imageViewerModal = document.getElementById('imageViewerModal');
if (imageViewerModal) {
    imageViewerModal.addEventListener('click', function(e) {
        if (e.target === this) {
            closeImageModal();
        }
    });
}
// Función para actualizar el estado del ticket
async function updateTicketStatus(ticketId, newStatus) {
    try {
        Utils.showLoading('Actualizando estado...');
        
        const ticketRef = doc(db, 'ticketsmesa', ticketId);
        
        await updateDoc(ticketRef, {
            estado: newStatus,
            fechaActualizacion: serverTimestamp()
        });
        
        // Si el estado es "cerrado", agregar fecha de finalización
        if (newStatus === 'cerrado') {
            await updateDoc(ticketRef, {
                fechaFinalizacion: serverTimestamp()
            });
        }
        
        Utils.hideLoading();
        
        Swal.fire({
            icon: 'success',
            title: 'Estado actualizado',
            text: `El estado del ticket ha sido cambiado a ${newStatus.replace(/_/g, ' ')}`,
            confirmButtonColor: '#3085d6'
        });
        
        // Actualizar la vista de detalles si está abierta
        if (document.getElementById('detailModal').style.display === 'block') {
            await TicketsController.showTicketDetails(ticketId);
        }
        
        // Actualizar la lista de tickets
        await TicketsController.loadUserTickets();
        
    } catch (error) {
        console.error("Error actualizando estado:", error);
        Utils.showError('No se pudo actualizar el estado del ticket');
    }
}

// Modificamos la función que inserta el select
const originalShowTicketDetails = TicketsController.showTicketDetails;
TicketsController.showTicketDetails = async function(ticketId) {
    await originalShowTicketDetails.call(this, ticketId);
    
    // Crear contenedor principal
    const modalContent = document.getElementById('detailContent');
    const statusControl = document.createElement('div');
    statusControl.className = 'status-control-container';
    statusControl.style.cssText = `
        background-color: #2c3e50;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        color: white;
        display: flex;
        align-items: center;
        gap: 15px;
        flex-wrap: wrap;
    `;
    
    // Obtener datos del ticket
    const ticketRef = doc(db, 'ticketsmesa', ticketId);
    const ticketSnap = await getDoc(ticketRef);
    const ticketData = ticketSnap.data();
    let currentStatus = ticketData.estado || 'pendiente_de_aceptación';
    let pauseComment = ticketData.pauseComment || '';
    
    // Contenedor para estado + comentario
    const statusInfoContainer = document.createElement('div');
    statusInfoContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 5px;
        flex-grow: 1;
    `;
    
    // Badge de estado
    const statusBadge = document.createElement('span');
    statusBadge.className = `current-status-badge ${currentStatus}`;
    statusBadge.textContent = currentStatus.replace(/_/g, ' ');
    statusBadge.style.cssText = `
        font-weight: bold;
        padding: 6px 12px;
        border-radius: 4px;
        text-transform: capitalize;
        margin-bottom: 8px;
        display: inline-block;
        width: fit-content;
        color: ${currentStatus === 'pendiente_de_aceptación' ? '#000' : '#fff'};
        background-color: ${getStatusColor(currentStatus)};
    `;
    statusInfoContainer.appendChild(statusBadge);
    
    // Mostrar comentario existente
    if (currentStatus === 'en_proceso' && pauseComment) {
        const wordCount = pauseComment.trim().split(/\s+/).length;
        const commentBadge = document.createElement('div');
        commentBadge.className = 'pause-comment-badge';
        commentBadge.innerHTML = `
            <div style="border-left: 3px solid #17a2b8; padding-left: 10px;">
                <strong style="color: white; font-weight: 600;">Razón de pausa:</strong>
                <p style="color: #e0e0e0; margin: 5px 0 0 0; max-height: 100px; overflow-y: auto; white-space: pre-wrap; line-height: 1.4;">${pauseComment}</p>
                <div style="color: #aaa; font-size: 0.8em; text-align: right;"></div>
            </div>
        `;
        statusInfoContainer.appendChild(commentBadge);
    }
    
    statusControl.appendChild(statusInfoContainer);
    
    // Selector de estados
    const statusSelect = document.createElement('select');
    statusSelect.className = 'status-select';
    statusSelect.style.cssText = `
        background-color: #333;
        color: white;
        border: 1px solid #444;
        padding: 6px 10px;
        border-radius: 4px;
        min-width: 200px;
    `;
    
    const statusOptions = [
        { value: 'pendiente_de_aceptación', text: 'Pendiente de aceptación' },
        { value: 'aceptado', text: 'Aceptado' },
        { value: 'en_proceso', text: 'En pausa' },
        { value: 'en_camino', text: 'En camino' },
        { value: 'completado', text: 'Completado' },
        { value: 'cerrado', text: 'Cerrado' }
    ];
    
    statusOptions.forEach(option => {
        const optElement = document.createElement('option');
        optElement.value = option.value;
        optElement.textContent = option.text;
        optElement.selected = option.value === currentStatus;
        statusSelect.appendChild(optElement);
    });
    
    statusControl.appendChild(statusSelect);
    
    // Botón de guardar
    const saveButton = document.createElement('button');
    saveButton.className = 'save-status-btn';
    saveButton.innerHTML = '<i class="fas fa-save"></i>';
    saveButton.style.cssText = `
        background-color: #28a745;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s;
    `;
    
    // --- EVENT LISTENER DEL BOTÓN GUARDAR ---
    saveButton.onclick = async () => {
        const newStatus = statusSelect.value;
        let comment = pauseComment;
        
        if (newStatus === 'en_proceso') {
            const { value: commentText } = await Swal.fire({
                title: '<span style="color:white">Razón de la pausa</span>',
                html: `
                    <textarea id="commentTextarea" 
                              style="background:#222; color:white; border:1px solid #444; width:100%; min-height:100px; padding:10px;"
                              placeholder="Escribe aquí la razón (máximo 200 palabras)...">${pauseComment}</textarea>
                    <div id="wordCounter" style="color:#aaa; text-align:right; font-size:0.8em;">0/200 palabras</div>
                `,
                background: '#000',
                showCancelButton: true,
                confirmButtonText: 'Guardar',
                cancelButtonText: 'Cancelar',
                preConfirm: () => {
                    const textarea = document.getElementById('commentTextarea');
                    const text = textarea.value.trim();
                    const wordCount = text.split(/\s+/).length;
                    
                    if (!text) {
                        Swal.showValidationMessage('Debes escribir una razón para la pausa');
                        return false;
                    }
                    if (wordCount > 200) {
                        Swal.showValidationMessage(`Has excedido el límite de 200 palabras (${wordCount})`);
                        return false;
                    }
                    return text;
                },
                didOpen: () => {
                    const textarea = document.getElementById('commentTextarea');
                    const counter = document.getElementById('wordCounter');
                    
                    textarea.addEventListener('input', () => {
                        const text = textarea.value.trim();
                        const wordCount = text ? text.split(/\s+/).length : 0;
                        counter.textContent = `${wordCount}/200 palabras`;
                    });
                    
                    const initialWordCount = pauseComment ? pauseComment.trim().split(/\s+/).length : 0;
                    counter.textContent = `${initialWordCount}/200 palabras`;
                }
            });
            
            if (commentText === undefined) return;
            comment = commentText;
        }
        
        try {
            // 1. Prepara los datos para guardar
            const updateData = {
                estado: newStatus,
                updatedAt: serverTimestamp(),
                ...(newStatus === 'en_proceso' ? { pauseComment: comment } : { pauseComment: '' })
            };
            
            // 2. Guarda en la base de datos y ESPERA a que termine
            await updateDoc(ticketRef, updateData);
            
            // ✅ INICIA CÓDIGO PARA ACTUALIZACIÓN INMEDIATA ✅
            // Esta parte se ejecuta DESPUÉS de que la base de datos se actualizó correctamente.
            
            currentStatus = newStatus;
            pauseComment = newStatus === 'en_proceso' ? comment : '';
            
            // 3. Actualiza el badge de estado en el modal
            statusBadge.className = `current-status-badge ${newStatus}`;
            statusBadge.textContent = newStatus.replace(/_/g, ' ');
            statusBadge.style.backgroundColor = getStatusColor(newStatus);
            statusBadge.style.color = newStatus === 'pendiente_de_aceptación' ? '#000' : '#fff';
            
            // 4. Actualiza el comentario de pausa en el modal
            const existingComment = statusInfoContainer.querySelector('.pause-comment-badge');
            if (existingComment) existingComment.remove();
            
            if (newStatus === 'en_proceso' && comment) {
                const wordCount = comment.trim().split(/\s+/).length;
                const commentBadge = document.createElement('div');
                commentBadge.className = 'pause-comment-badge';
                commentBadge.innerHTML = `
                    <div style="border-left: 3px solid #17a2b8; padding-left: 10px;">
                        <strong style="color: white; font-weight: 600;">Razón de pausa:</strong>
                        <p style="color: #e0e0e0; margin: 5px 0 0 0; max-height: 100px; overflow-y: auto; white-space: pre-wrap; line-height: 1.4;">${comment}</p>
                        <div style="color: #aaa; font-size: 0.8em; text-align: right;">${wordCount}/200 palabras</div>
                    </div>
                `;
                statusInfoContainer.appendChild(commentBadge);
            }
            
            // ✅ TERMINA CÓDIGO PARA ACTUALIZACIÓN INMEDIATA ✅
            
            // 5. Muestra la alerta de éxito
            await Swal.fire({
                icon: 'success',
                title: '¡Actualizado!',
                text: 'El estado del ticket ha sido actualizado',
                timer: 1500,
                showConfirmButton: false,
                background: '#000',
                color: 'white'
            });
            
        } catch (error) {
            console.error("Error updating ticket: ", error);
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: 'No se pudo actualizar el ticket: ' + error.message,
                background: '#000',
                color: 'white'
            });
        }
    };
    
    statusControl.appendChild(saveButton);
    modalContent.insertBefore(statusControl, modalContent.firstChild);
};

// Función auxiliar para colores de estado
function getStatusColor(status) {
    const colors = {
        'pendiente_de_aceptación': '#ffc107',
        'aceptado': '#17a2b8',
        'en_proceso': '#fd7e14',
        'en_camino': '#007bff',
        'completado': '#28a745',
        'cerrado': '#6c757d'
    };
    return colors[status] || '#6c757d';
}
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Crear botón hamburguesa
    const hamburgerBtn = document.createElement('button');
    hamburgerBtn.className = 'sidebar-toggle';
    hamburgerBtn.innerHTML = '<span></span><span></span><span></span>';
    document.body.appendChild(hamburgerBtn);

    // Crear overlay
    const overlay = document.createElement('div');
    overlay.className = 'sidebar-overlay';
    document.body.appendChild(overlay);

    // Elementos existentes
    const sidebar = document.querySelector('.sidebar');
    const mainContent = document.querySelector('.main-content');

    // Evento para abrir/cerrar menú
    hamburgerBtn.addEventListener('click', function() {
        this.classList.toggle('active');
        sidebar.classList.toggle('active');
        overlay.classList.toggle('active');
        document.body.classList.toggle('menu-open');
    });

    // Cerrar menú al hacer clic en overlay
    overlay.addEventListener('click', function() {
        hamburgerBtn.classList.remove('active');
        sidebar.classList.remove('active');
        this.classList.remove('active');
        document.body.classList.remove('menu-open');
    });

    // Cerrar menú al hacer clic en enlaces del sidebar
    const sidebarLinks = document.querySelectorAll('.sidebar a, .sidebar button');
    sidebarLinks.forEach(link => {
        link.addEventListener('click', function() {
            // Solo cerrar si es un enlace (no botones de acción)
            if (this.tagName === 'A') {
                hamburgerBtn.classList.remove('active');
                sidebar.classList.remove('active');
                overlay.classList.remove('active');
                document.body.classList.remove('menu-open');
            }
        });
    });

    // Mejorar accesibilidad
    hamburgerBtn.setAttribute('aria-label', 'Menú de navegación');
    hamburgerBtn.setAttribute('aria-expanded', 'false');
    
    hamburgerBtn.addEventListener('click', function() {
        const expanded = this.classList.contains('active');
        this.setAttribute('aria-expanded', expanded);
        sidebar.setAttribute('aria-hidden', !expanded);
    });
});

</script>

<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
</body>
</html>
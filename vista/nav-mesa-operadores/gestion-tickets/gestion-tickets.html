<!DOCTYPE html>
<html lang="es">
<head>
    <link rel="manifest" href="../../manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tickets | RSI Enterprise</title>
    <link rel="stylesheet" href="gestion-tickets.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
    <div class="../css/img/Logo-RSI-OFICIAL.png"></div>
    <div class="sidebar">
        <div class="user-profile">
            <img id="userAvatar" src="https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png" alt="Logo RSI" class="user-avatar">
            <h2 class="user-name" id="userNameDisplay">Cargando...</h2>
            <span class="user-area" id="userAreaDisplay">ÁREA: Cargando...</span>
        </div>

        <div class="logout-container">
            <button class="logout-btn" id="logoutBtn">
                <i class="fas fa-sign-out-alt"></i> Cerrar Sesión
            </button>
            
            <a href="../fin-asistencia/fin-asistencia.html" class="asistencia-btn" id="endAssistanceLink">
                <i class="fas fa-user-clock"></i> Terminar Asistencia
            </a>

             <a href="../Rembolsos/rembolso.html" class="asistencia-btn" id="endAssistanceLink">
                <i class="fas fa-money-bill-transfer"></i> Reembolsos
            </a>
            
            <button class="asistencia-btn" id="createTicketBtn" style="display: none;">
                <i class="fas fa-plus-circle"></i> Levantar Ticket
            </button>
        </div>

        <div class="stats-header">
            <h3 class="stats-title">Mis Estadísticas</h3>
        </div>

        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-title"><i class="fas fa-ticket-alt"></i> Total Tickets</div>
                <div id="totalTickets" class="stat-value">0</div>
                <div class="stat-trend trend-up">
                    <i class="fas fa-arrow-up"></i> <span>5% vs último mes</span>
                </div>
            </div>
            <div class="stat-card">
                <div class="stat-title"><i class="fas fa-clock"></i> Tiempo promedio</div>
                <div id="avgTime" class="stat-value">0 días</div>
                <div class="stat-trend trend-down">
                    <i class="fas fa-arrow-down"></i> <span>2 días menos</span>
                </div>
            </div>
        </div>

        <div class="tickets-chart">
            <div class="chart-title">Estado de mis tickets</div>
            <div class="chart-bars" id="statusChart">
                </div>
        </div>
        
        <div class="priority-stats">
            <div class="chart-title">Tickets por Prioridad</div>
            <div class="priority-item">
                <span class="priority-name">
                    <span class="priority-indicator priority-high"></span> Alta
                </span>
                <span id="highPriority" class="priority-count">0</span>
            </div>
            <div class="priority-item">
                <span class="priority-name">
                    <span class="priority-indicator priority-medium"></span> Media
                </span>
                <span id="mediumPriority" class="priority-count">0</span>
            </div>
            <div class="priority-item">
                <span class="priority-name">
                    <span class="priority-indicator priority-low"></span> Baja
                </span>
                <span id="lowPriority" class="priority-count">0</span>
            </div>
        </div><br>

        <div id="mensajeAcceso" style="display: none;"></div>
    </div>

    <div class="main-content">
        <div class="crud-header">
            <center>
            <h1 class="page-title">Mis Tickets</h1>
            </center>

            <button class="filter-btn" id="filterBtn">
                <i class="fas fa-filter"></i> 
                <span id="filterText">Ver Finalizados</span>
            </button>
        </div>

        <div class="tickets-grid" id="ticketsContainer">
            <div class="no-tickets">
                <i class="fas fa-ticket-alt"></i>
                <h3>Cargando tickets...</h3>
                <p>Por favor espera mientras se cargan tus tickets</p>
            </div>
        </div>
    </div>

    <div id="detailModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="detailTitle">Detalles del Ticket</h2>
                <span class="close">&times;</span>
            </div>
            <div id="detailContent">
                </div>
            <div class="modal-footer">
                <a href="#" class="action-btn finish-btn" id="finishTicketBtn" style="display: none;">
                    <i class="fas fa-check-circle"></i> Finalizar Ticket
                </a>
                <button type="button" class="action-btn edit-btn" id="editFinishBtn" style="display: none;">
                    <i class="fas fa-edit"></i> Modificar Finalización
                </button>
                <button type="button" class="cancel-btn" id="closeDetailBtn">
                    <i class="fas fa-times"></i> Cerrar
                </button>
            </div>
        </div>
    </div>

    <div id="imageViewerModal" class="modal">
        <div class="modal-content" style="max-width: 90%; max-height: 90vh; background: transparent; box-shadow: none;">
            <span class="close" style="position: absolute; top: 15px; right: 15px; color: rgb(0, 0, 0); font-size: 35px; z-index: 100;">&times;</span>
            <img id="expandedImage" style="width: 100%; height: auto; max-height: 90vh; object-fit: contain;">
        </div>
    </div>

    <div id="pdfProgressModal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <div class="modal-header">
                <h2>Generando PDF</h2>
            </div>
            <div class="modal-body">
                <div class="pdf-progress">
                    <i class="fas fa-file-pdf fa-3x" style="color: #e74c3c; margin-bottom: 20px;"></i>
                    <p>Procesando información del ticket...</p>
                    <div class="progress-bar">
                        <div class="progress-fill" id="pdfProgressFill"></div>
                    </div>
                    <p id="pdfProgressText">0%</p>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
    // Esquemas de datos
    const DataSchemas = {
        EVIDENCIA: {
            ticketId: '',
            colaboradorId: '',
            colaboradorNombre: '',
            descripcion: '',
            imagenes: [],
            fechaCreacion: null,
            fechaActualizacion: null,
            estado: 'pendiente' // pendiente | completado
        },
        TICKET: {
            evidenciasCompletadas: [], // array de colaboradorIds que han completado
            todosCompletados: false
        },
        PDF: {
            ticketId: '',
            nombreArchivo: '',
            fechaCreacion: null,
            colaboradorId: '',
            colaboradorNombre: '',
            contenido: '', // base64 del PDF
            tamaño: 0
        }
    };

    // Clase para manejar el estado del ticket
    class TicketManager {
        constructor() {
            this.currentTicketId = null;
            this.currentTicketStatus = null;
            this.showFinalized = false; // Estado del filtro
        }

        setCurrentTicket(ticketId, status) {
            this.currentTicketId = ticketId;
            this.currentTicketStatus = status;
        }

        clearCurrentTicket() {
            this.currentTicketId = null;
            this.currentTicketStatus = null;
        }

        toggleFilter() {
            this.showFinalized = !this.showFinalized;
            return this.showFinalized;
        }
    }

    // Instancia única del manager
    const ticketManager = new TicketManager();

    // Importar módulos necesarios de Firebase v9
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
    import { 
        getFirestore, 
        collection, 
        query, 
        where,
        getDocs,
        orderBy,
        doc,
        getDoc,
        limit,
        updateDoc,
        addDoc,
        serverTimestamp
    } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
    import { 
        getAuth, 
        GoogleAuthProvider, 
        signInWithPopup, 
        signOut,
        onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";

    // Configuración de Firebase
    const firebaseConfig = {
        apiKey: "AIzaSyBJy992gkvsT77-_fMp_O_z99wtjZiK77Y",
        authDomain: "rsienterprise.firebaseapp.com",
        databaseURL: "https://rsienterprise-default-rtdb.firebaseio.com",
        projectId: "rsienterprise",
        storageBucket: "rsienterprise.appspot.com",
        messagingSenderId: "1063117165770",
        appId: "1:1063117165770:web:8555f26b25ae80bc42d033",
        measurementId: "G-38F2DBG9HE"
    };

    // Inicializar Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const provider = new GoogleAuthProvider();

    // Configurar el proveedor de Google
    provider.addScope('email');
    provider.addScope('profile');

    // Elementos del DOM
    const DOM = {
        userAvatar: document.getElementById('userAvatar'),
        userNameDisplay: document.getElementById('userNameDisplay'),
        userAreaDisplay: document.getElementById('userAreaDisplay'),
        ticketsContainer: document.getElementById('ticketsContainer'),
        totalTickets: document.getElementById('totalTickets'),
        avgTime: document.getElementById('avgTime'),
        highPriority: document.getElementById('highPriority'),
        mediumPriority: document.getElementById('mediumPriority'),
        lowPriority: document.getElementById('lowPriority'),
        statusChart: document.getElementById('statusChart'),
        logoutBtn: document.getElementById('logoutBtn'),
        // endAssistanceBtn: document.getElementById('endAssistanceBtn'), // ELIMINADO
        filterBtn: document.getElementById('filterBtn'),
        filterText: document.getElementById('filterText'),
        finishTicketBtn: document.getElementById('finishTicketBtn'),
        editFinishBtn: document.getElementById('editFinishBtn')
    };

    // Estado de la aplicación
    const AppState = {
        currentUser: null,
        userData: null,
        userRole: null,
        lastCheckedTicketId : null,
        ticketCheckInterval: null,
        notificationCheckInterval: 10000, // 10 segundos inicialmente
        allTickets: [] // Almacenar todos los tickets
    };

    // En tu módulo principal, después de definir AppState:
    window.AppState = AppState;
    // Disparar evento cuando esté listo
    document.dispatchEvent(new Event('AppStateReady'));

    // Generador de PDF
    class PDFGenerator {
        constructor() {
            this.jsPDF = window.jspdf.jsPDF;
        }

        async generateTicketPDF(ticketData, evidencias) {
            try {
                this.showProgressModal();
                this.updateProgress(10, 'Inicializando generador PDF...');

                const pdf = new this.jsPDF('p', 'mm', 'a4');
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                let yPosition = 20;

                // Header con logo
                this.updateProgress(20, 'Añadiendo header...');
                await this.addHeader(pdf, pageWidth, yPosition);
                yPosition += 40;

                // Información básica del ticket
                this.updateProgress(30, 'Añadiendo información básica...');
                yPosition = this.addBasicInfo(pdf, ticketData, yPosition, pageWidth);

                // Información adicional
                this.updateProgress(40, 'Añadiendo información adicional...');
                yPosition = this.addAdditionalInfo(pdf, ticketData, yPosition, pageWidth);

                // Evidencias de colaboradores
                this.updateProgress(50, 'Procesando evidencias...');
                if (evidencias && evidencias.length > 0) {
                    for (let i = 0; i < evidencias.length; i++) {
                        this.updateProgress(50 + (i / evidencias.length) * 40, 'Añadiendo evidencias...');
                        yPosition = await this.addEvidenceSection(pdf, evidencias[i], yPosition, pageWidth, pageHeight);
                    }
                }

                this.updateProgress(95, 'Finalizando PDF...');
                
                // Guardar en Firebase
                const pdfBase64 = pdf.output('datauristring');
                await this.savePDFToFirebase(ticketData.id, pdfBase64);

                this.updateProgress(100, 'PDF generado exitosamente');
                
                // Descargar PDF
                const fileName = `Ticket_${ticketData.id.substring(0, 8)}_${new Date().toISOString().split('T')[0]}.pdf`;
                pdf.save(fileName);

                setTimeout(() => {
                    this.hideProgressModal();
                    Swal.fire({
                        icon: 'success',
                        title: 'PDF Generado',
                        text: 'El PDF se ha generado y guardado exitosamente',
                        confirmButtonColor: '#3085d6'
                    });
                }, 1000);

            } catch (error) {
                console.error('Error generando PDF:', error);
                this.hideProgressModal();
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: 'No se pudo generar el PDF: ' + error.message,
                    confirmButtonColor: '#3085d6'
                });
            }
        }

        async addHeader(pdf, pageWidth, yPosition) {
            // Título principal
            pdf.setFontSize(20);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(102, 126, 234);
            pdf.text('REPORTE DE TICKET - RSI ENTERPRISE', pageWidth / 2, yPosition, { align: 'center' });
            
            // Línea decorativa
            pdf.setDrawColor(102, 126, 234);
            pdf.setLineWidth(2);
            pdf.line(20, yPosition + 5, pageWidth - 20, yPosition + 5);
            
            // Fecha de generación
            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(100, 100, 100);
            pdf.text(`Generado el: ${new Date().toLocaleDateString('es-MX')} a las ${new Date().toLocaleTimeString('es-MX')}`, pageWidth - 20, yPosition + 15, { align: 'right' });
        }

        addBasicInfo(pdf, ticketData, yPosition, pageWidth) {
            const shortId = ticketData.id.substring(0, 8);
            
            // Título de sección
            pdf.setFontSize(14);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(44, 62, 80);
            pdf.text('INFORMACIÓN BÁSICA', 20, yPosition);
            yPosition += 10;

            // Crear tabla de información básica
            const basicInfo = [
                ['ID del Ticket:', `#${shortId.toUpperCase()}`],
                ['Título:', ticketData.titulo || 'Sin título'],
                ['Estado:', (ticketData.estado || 'desconocido').replace('_', ' ').toUpperCase()],
                ['Prioridad:', (ticketData.prioridad || 'media').toUpperCase()],
                ['Área:', ticketData.area || 'General'],
                ['Responsable:', ticketData.responsableNombre || 'No asignado'],
                ['Fecha de Creación:', this.formatDate(ticketData.fechaCreacion)],
                ['Última Actualización:', this.formatDate(ticketData.fechaActualizacion)],
            ];

            if (ticketData.fechaFinalizacion) {
                basicInfo.push(['Fecha de Finalización:', this.formatDate(ticketData.fechaFinalizacion)]);
            }

            yPosition = this.addTable(pdf, basicInfo, yPosition, pageWidth);
            
            return yPosition + 10;
        }

        addAdditionalInfo(pdf, ticketData, yPosition, pageWidth) {
            // Descripción del ticket
            if (ticketData.descripcionActividades) {
                pdf.setFontSize(14);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(44, 62, 80);
                pdf.text('DESCRIPCIÓN DEL PROYECTO', 20, yPosition);
                yPosition += 10;

                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(0, 0, 0);
                
                const splitDescription = pdf.splitTextToSize(ticketData.descripcionActividades, pageWidth - 40);
                pdf.text(splitDescription, 20, yPosition);
                yPosition += splitDescription.length * 5 + 10;
            }

            // Información adicional si existe
            const additionalData = [];
            if (ticketData.servicio) additionalData.push(['Servicio:', ticketData.servicio]);
            if (ticketData.proyecto) additionalData.push(['Proyecto:', ticketData.proyecto]);
            if (ticketData.ordenServicio) additionalData.push(['Orden de Servicio:', ticketData.ordenServicio]);
            if (ticketData.rfc) additionalData.push(['RFC:', ticketData.rfc]);
            if (ticketData.direccionFiscal) additionalData.push(['Dirección Fiscal:', ticketData.direccionFiscal]);
            if (ticketData.cuenta) additionalData.push(['Cuenta:', ticketData.cuenta]);

            if (additionalData.length > 0) {
                pdf.setFontSize(14);
                pdf.setFont('helvetica', 'bold');
                pdf.text('INFORMACIÓN ADICIONAL', 20, yPosition);
                yPosition += 10;
                
                yPosition = this.addTable(pdf, additionalData, yPosition, pageWidth);
                yPosition += 10;
            }

            return yPosition;
        }

        async addEvidenceSection(pdf, evidencia, yPosition, pageWidth, pageHeight) {
            // Verificar si necesitamos una nueva página
            if (yPosition > pageHeight - 50) {
                pdf.addPage();
                yPosition = 20;
            }

            // Título de evidencias del colaborador
            pdf.setFontSize(14);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(44, 62, 80);
            pdf.text(`EVIDENCIAS DE: ${evidencia.colaboradorNombre}`, 20, yPosition);
            yPosition += 10;

            // Descripción de la evidencia
            if (evidencia.descripcion) {
                pdf.setFontSize(12);
                pdf.setFont('helvetica', 'bold');
                pdf.text('Descripción del trabajo realizado:', 20, yPosition);
                yPosition += 8;

                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'normal');
                const splitDescription = pdf.splitTextToSize(evidencia.descripcion, pageWidth - 40);
                pdf.text(splitDescription, 20, yPosition);
                yPosition += splitDescription.length * 5 + 10;
            }

            // Imágenes de evidencia
            if (evidencia.imagenes && evidencia.imagenes.length > 0) {
                pdf.setFontSize(12);
                pdf.setFont('helvetica', 'bold');
                pdf.text(`Imágenes de evidencia (${evidencia.imagenes.length}):`, 20, yPosition);
                yPosition += 10;

                const imageWidth = 73; // 7.3 cm
                const imageHeight = 100; // 10 cm
                const imagesPerRow = 2;
                let imageCount = 0;

                for (const imageUrl of evidencia.imagenes) {
                    try {
                        // Verificar si necesitamos una nueva página
                        if (yPosition + imageHeight > pageHeight - 20) {
                            pdf.addPage();
                            yPosition = 20;
                        }

                        const xPosition = 20 + (imageCount % imagesPerRow) * (imageWidth + 10);
                        
                        // Añadir imagen
                        await this.addImageToPDF(pdf, imageUrl, xPosition, yPosition, imageWidth, imageHeight);
                        
                        imageCount++;
                        
                        // Si completamos una fila, avanzar yPosition
                        if (imageCount % imagesPerRow === 0) {
                            yPosition += imageHeight + 10;
                        }
                    } catch (error) {
                        console.error('Error añadiendo imagen:', error);
                    }
                }

                // Si la última fila no está completa, avanzar yPosition
                if (imageCount % imagesPerRow !== 0) {
                    yPosition += imageHeight + 10;
                }
            }

            return yPosition + 10;
        }

        async addImageToPDF(pdf, imageUrl, x, y, width, height) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = function() {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        canvas.width = width * 4; // Resolución más alta
                        canvas.height = height * 4;
                        
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        const dataURL = canvas.toDataURL('image/jpeg', 0.8);
                        
                        pdf.addImage(dataURL, 'JPEG', x, y, width, height);
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                };
                
                img.onerror = () => reject(new Error('No se pudo cargar la imagen'));
                img.src = imageUrl;
            });
        }

        addTable(pdf, data, yPosition, pageWidth) {
            const rowHeight = 8;
            const colWidth = (pageWidth - 40) / 2;

            data.forEach(([label, value]) => {
                // Fondo alternativo para las filas
                pdf.setFillColor(248, 249, 250);
                pdf.rect(20, yPosition - 5, pageWidth - 40, rowHeight, 'F');
                
                // Texto del label
                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(44, 62, 80);
                pdf.text(label, 25, yPosition);
                
                // Texto del valor
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(0, 0, 0);
                const splitValue = pdf.splitTextToSize(value, colWidth - 10);
                pdf.text(splitValue, 25 + colWidth, yPosition);
                
                yPosition += Math.max(rowHeight, splitValue.length * 5);
            });

            return yPosition;
        }

        formatDate(timestamp) {
            if (!timestamp) return 'N/A';
            try {
                const date = timestamp.toDate();
                return date.toLocaleDateString('es-MX', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (error) {
                return 'Fecha inválida';
            }
        }

        async savePDFToFirebase(ticketId, pdfBase64) {
            try {
                const pdfData = {
                    ticketId: ticketId,
                    nombreArchivo: `Ticket_${ticketId.substring(0, 8)}_${new Date().toISOString().split('T')[0]}.pdf`,
                    fechaCreacion: serverTimestamp(),
                    colaboradorId: AppState.userData.colaboradorId,
                    colaboradorNombre: AppState.userData.NOMBRE,
                    contenido: pdfBase64,
                    tamaño: Math.round(pdfBase64.length * 0.75) // Aproximar tamaño
                };

                await addDoc(collection(db, 'pdfMesa'), pdfData);
                console.log('PDF guardado en Firebase exitosamente');
            } catch (error) {
                console.error('Error guardando PDF en Firebase:', error);
                throw error;
            }
        }

        showProgressModal() {
            document.getElementById('pdfProgressModal').style.display = 'block';
        }

        hideProgressModal() {
            document.getElementById('pdfProgressModal').style.display = 'none';
        }

        updateProgress(percentage, text) {
            const progressFill = document.getElementById('pdfProgressFill');
            const progressText = document.getElementById('pdfProgressText');
            
            if (progressFill) progressFill.style.width = percentage + '%';
            if (progressText) progressText.textContent = Math.round(percentage) + '%';
            
            // Actualizar texto de progreso si se proporciona
            const progressTextElement = document.querySelector('#pdfProgressModal .modal-body p');
            if (progressTextElement && text) {
                progressTextElement.textContent = text;
            }
        }
    }

    // Instancia del generador de PDF
    const pdfGenerator = new PDFGenerator();

    // Funciones de utilidad
    const Utils = {
        showLoading: (message = 'Cargando...') => {
            Swal.fire({
                title: message,
                allowOutsideClick: false,
                didOpen: () => Swal.showLoading()
            });
        },
        
        hideLoading: () => Swal.close(),
        
        showError: (message, title = 'Error') => {
            Swal.fire({
                icon: 'error',
                title: title,
                text: message,
                confirmButtonColor: '#3085d6'
            });
        },
        
        formatDate: (timestamp) => {
            if (!timestamp) return 'N/A';
            try {
                const date = timestamp.toDate();
                return date.toLocaleDateString('es-MX', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (error) {
                console.error("Error formateando fecha:", error);
                return 'Fecha inválida';
            }
        },
        
        getBadgeClass: (status) => {
            switch(status) {
                case 'finalizado': 
                case 'completado': 
                case 'cerrado': 
                    return 'badge-success';
                case 'en_proceso': 
                case 'en_camino': 
                    return 'badge-warning';
                case 'pendiente': 
                case 'pendiente_de_aceptación': 
                    return 'badge-danger';
                case 'aceptado': 
                    return 'badge-info';
                default: 
                    return 'badge-info';
            }
        },
        
        getStatusIcon: (status) => {
            switch(status) {
                case 'finalizado': 
                case 'completado': 
                case 'cerrado': 
                    return 'fa-check-circle';
                case 'en_proceso': 
                    return 'fa-spinner';
                case 'en_camino': 
                    return 'fa-truck';
                case 'pendiente': 
                case 'pendiente_de_aceptación': 
                    return 'fa-clock';
                case 'aceptado': 
                    return 'fa-check';
                default: 
                    return 'fa-question-circle';
            }
        },
        
        getPriorityClass: (priority) => {
            switch(priority) {
                case 'alta': return 'priority-high';
                case 'media': return 'priority-medium';
                case 'baja': return 'priority-low';
                default: return 'priority-medium';
            }
        },
        
        updateStatusChart: (pending, inProgress, completed) => {
            try {
                const maxValue = Math.max(pending, inProgress, completed, 1);
                DOM.statusChart.innerHTML = `
                    <div class="chart-bar">
                        <div class="bar bar-pendiente" style="height: ${(pending / maxValue) * 80}px;" data-value="${pending}"></div>
                        <div class="bar-label">Pendientes</div>
                    </div>
                    <div class="chart-bar">
                        <div class="bar bar-proceso" style="height: ${(inProgress / maxValue) * 80}px;" data-value="${inProgress}"></div>
                        <div class="bar-label">En Proceso</div>
                    </div>
                    <div class="chart-bar">
                        <div class="bar bar-finalizado" style="height: ${(completed / maxValue) * 80}px;" data-value="${completed}"></div>
                        <div class="bar-label">Finalizados</div>
                    </div>
                `;
            } catch (error) {
                console.error("Error actualizando gráfico de estado:", error);
            }
        },
        
        async showNotification(title, body, ticketId) {
            try {
                if (!('Notification' in window)) {
                    console.log("Notificaciones no soportadas");
                    return false;
                }

                const permission = await Notification.requestPermission();
                
                if (permission === 'granted') {
                    if ('serviceWorker' in navigator) {
                        try {
                            const registration = await navigator.serviceWorker.ready;
                            
                            await registration.showNotification(title, {
                                body: body,
                                icon: 'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png',
                                badge: 'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png',
                                data: { 
                                    url: `https://rsienterprise.web.app/?ticketId=${ticketId}`,
                                    ticketId: ticketId
                                },
                                vibrate: [200, 100, 200],
                                actions: [
                                    { 
                                        action: 'view', 
                                        title: 'Ver Ticket',
                                        icon: 'https://rsienterprise.web.app/vista/css/img/icon-eye.png'
                                    }
                                ]
                            });
                            return true;
                        } catch (error) {
                            console.error("Error con Service Worker:", error);
                            // Fallback a notificación estándar
                            new Notification(title, {
                                body: body,
                                icon: 'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png'
                            });
                            return true;
                        }
                    } else {
                        // Notificación estándar si no hay service worker
                        new Notification(title, {
                            body: body,
                            icon: 'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png'
                        });
                        return true;
                    }
                }
                return false;
            } catch (error) {
                console.error("Error mostrando notificación:", error);
                return false;
            }
        }
    };

    // Controlador de Tickets
    const TicketsController = {
        processTickets: (querySnapshot) => {
            const tickets = [];
            querySnapshot.forEach((doc) => {
                try {
                    const data = doc.data();
                    tickets.push({
                        id: doc.id,
                        ...data,
                        fechaCreacion: data.fechaCreacion,
                        fechaActualizacion: data.fechaActualizacion || null
                    });
                } catch (error) {
                    console.error("Error procesando ticket:", error);
                }
            });
            return tickets;
        },

        filterTickets: (tickets, showFinalized) => {
            if (showFinalized) {
                return tickets.filter(ticket => ticket.estado === 'finalizado');
            } else {
                return tickets.filter(ticket => ticket.estado !== 'finalizado');
            }
        },

        renderTickets: (tickets) => {
            try {
                const filteredTickets = TicketsController.filterTickets(tickets, ticketManager.showFinalized);
                DOM.ticketsContainer.innerHTML = '';
                
                if (!filteredTickets || filteredTickets.length === 0) {
                    const message = ticketManager.showFinalized 
                        ? 'No tienes tickets finalizados'
                        : 'No tienes tickets pendientes o en proceso';
                        
                    DOM.ticketsContainer.innerHTML = `
                        <div class="no-tickets">
                            <i class="fas fa-ticket-alt"></i>
                            <h3>${message}</h3>
                            <p>Cuando ${ticketManager.showFinalized ? 'finalices' : 'te asignen'} tickets, aparecerán aquí</p>
                        </div>
                    `;
                    return;
                }

                // Calcular estadísticas para todos los tickets
                let pendingTickets = 0;
                let inProgressTickets = 0;
                let completedTickets = 0;
                let highPriority = 0;
                let mediumPriority = 0;
                let lowPriority = 0;

                tickets.forEach(ticket => {
                    // Actualizar contadores de estado
                    if (ticket.estado === 'pendiente') pendingTickets++;
                    else if (ticket.estado === 'en_proceso') inProgressTickets++;
                    else if (ticket.estado === 'finalizado') completedTickets++;
                    
                    // Actualizar contadores de prioridad
                    if (ticket.prioridad === 'alta') highPriority++;
                    else if (ticket.prioridad === 'media') mediumPriority++;
                    else if (ticket.prioridad === 'baja') lowPriority++;
                });

                let html = '';
                filteredTickets.forEach(ticket => {
                    try {
                        // Validaciones robustas
                        const ticketId = ticket.id || 'ID-NO-DISPONIBLE';
                        const shortId = ticketId.substring(0, 8);
                        const estado = ticket.estado || 'desconocido';
                        const titulo = ticket.titulo || 'Sin título';
                        const descripcion = ticket.descripcionActividades || 'Sin descripción';
                        const prioridad = ticket.prioridad || 'media';
                        const area = ticket.area || 'General';
                        const fechaCreacion = ticket.fechaCreacion || null;
                        
                        // Información del colaborador (si existe)
                        const colaboradorInfo = ticket.colaborador ? `
                            <div class="ticket-meta">
                                <span class="badge badge-primary">
                                    <i class="fas fa-user"></i> ${ticket.colaborador.nombre || 'Sin nombre'}
                                </span>
                                <span class="badge badge-primary">
                                    <i class="fas fa-briefcase"></i> ${ticket.colaborador.puesto || 'Sin puesto'}
                                </span>
                            </div>
                        ` : '';
                        
                        html += `
                            <div class="ticket-card">
                                <div class="ticket-header">
                                    <span class="ticket-id">#${shortId.toUpperCase()}</span>
                                    <span class="badge ${Utils.getBadgeClass(estado)}">
                                        <i class="fas ${Utils.getStatusIcon(estado)}"></i> ${estado.replace('_', ' ')}
                                    </span>
                                </div>
                                <h3 class="ticket-title">${titulo}</h3>
                                <p class="ticket-desc">${descripcion.substring(0, 120)}${descripcion.length > 120 ? '...' : ''}</p>
                                
                                <div class="ticket-meta">
                                    <span class="badge badge-primary">
                                        <span class="priority-indicator ${Utils.getPriorityClass(prioridad)}"></span>
                                        ${prioridad}
                                    </span>
                                    <span class="badge badge-primary">
                                        <i class="fas fa-layer-group"></i> ${area}
                                    </span>
                                </div>
                                
                                ${colaboradorInfo}
                                
                                <div class="ticket-date">
                                    <i class="fas fa-calendar-alt"></i> ${Utils.formatDate(fechaCreacion)}
                                </div>
                                
                                <button class="action-btn view" data-id="${ticketId}">
                                    <i class="fas fa-eye"></i> Ver detalles
                                </button>
                            </div>
                        `;
                    } catch (error) {
                        console.error("Error renderizando ticket:", error);
                    }
                });
                
                // Actualizar estadísticas
                DOM.totalTickets.textContent = tickets.length;
                DOM.highPriority.textContent = highPriority;
                DOM.mediumPriority.textContent = mediumPriority;
                DOM.lowPriority.textContent = lowPriority;
                Utils.updateStatusChart(pendingTickets, inProgressTickets, completedTickets);
                
                DOM.ticketsContainer.innerHTML = html;
                
                // Agregar event listeners para los botones de ver detalles
                document.querySelectorAll('.action-btn.view').forEach(btn => {
                    btn.addEventListener('click', () => TicketsController.showTicketDetails(btn.dataset.id));
                });
            } catch (error) {
                console.error("Error renderizando tickets:", error);
                Utils.showError("Error al mostrar los tickets");
            }
        },

        async loadUserTickets() {
            try {
                Utils.showLoading('Cargando tickets...');
                
                // Verificar que tenemos los datos del usuario
                if (!AppState.userData || !AppState.userData.nombreCompleto) {
                    throw new Error('Datos de usuario incompletos');
                }
                
                const ticketsRef = collection(db, 'ticketsmesa');
                const nombreResponsable = AppState.userData.nombreCompleto;
                const colaboradorId = AppState.userData.colaboradorId;
                
                console.log("Buscando tickets para:", nombreResponsable, "o colaborador ID:", colaboradorId);
                
                let querySnapshot;
                try {
                    // Ejecutar ambas consultas
                    const qResponsable = query(
                        ticketsRef,
                        where("responsableNombre", "==", nombreResponsable),
                        orderBy("fechaCreacion", "desc")
                    );
                    
                    const qColaborador = query(
                        ticketsRef,
                        where("colaboradores", "array-contains", colaboradorId),
                        orderBy("fechaCreacion", "desc")
                    );
                    
                    const [snapshotResponsable, snapshotColaborador] = await Promise.all([
                        getDocs(qResponsable),
                        getDocs(qColaborador)
                    ]);
                    
                    // Combinar resultados evitando duplicados
                    const allTickets = new Map();
                    
                    snapshotResponsable.forEach(doc => {
                        allTickets.set(doc.id, doc);
                    });
                    
                    snapshotColaborador.forEach(doc => {
                        allTickets.set(doc.id, doc);
                    });
                    
                    querySnapshot = {
                        docs: Array.from(allTickets.values()),
                        empty: allTickets.size === 0,
                        size: allTickets.size,
                        forEach: function(callback) {
                            this.docs.forEach(doc => callback(doc));
                        }
                    };
                    
                } catch (error) {
                    if (error.code === 'failed-precondition') {
                        console.warn("Índice faltante, cargando tickets sin ordenar...");
                        // Intentar sin ordenar
                        const qResponsable = query(
                            ticketsRef,
                            where("responsableNombre", "==", nombreResponsable)
                        );
                        
                        const qColaborador = query(
                            ticketsRef,
                            where("colaboradores", "array-contains", colaboradorId)
                        );
                        
                        const [snapshotResponsable, snapshotColaborador] = await Promise.all([
                            getDocs(qResponsable),
                            getDocs(qColaborador)
                        ]);
                        
                        // Combinar resultados
                        const allTickets = new Map();
                        
                        snapshotResponsable.forEach(doc => {
                            allTickets.set(doc.id, doc);
                        });
                        
                        snapshotColaborador.forEach(doc => {
                            allTickets.set(doc.id, doc);
                        });
                        
                        querySnapshot = {
                            docs: Array.from(allTickets.values()),
                            empty: allTickets.size === 0,
                            size: allTickets.size,
                            forEach: function(callback) {
                                this.docs.forEach(doc => callback(doc));
                            }
                        };
                    } else {
                        throw error;
                    }
                }
                
                console.log("Tickets encontrados:", querySnapshot.size);
                
                const tickets = this.processTickets(querySnapshot);
                const ticketsEnriquecidos = await this.enriquecerTicketsConColaborador(tickets);
                
                // Guardar todos los tickets en el estado global
                AppState.allTickets = ticketsEnriquecidos;
                
                this.renderTickets(ticketsEnriquecidos);
                
                // Verificar si hay tickets nuevos para notificar
                if (tickets.length > 0) {
                    const latestTicketId = tickets[0].id;
                    if (AppState.lastCheckedTicketId !== latestTicketId) {
                        AppState.lastCheckedTicketId = latestTicketId;
                    }
                }
                
            } catch (error) {
                console.error("Error cargando tickets:", error);
                Utils.showError("No se pudieron cargar los tickets");
                DOM.ticketsContainer.innerHTML = `
                    <div class="no-tickets">
                        <i class="fas fa-exclamation-triangle"></i>
                        <h3>Error al cargar tickets</h3>
                        <p>No se pudieron cargar los tickets. Intenta nuevamente.</p>
                    </div>
                `;
            } finally {
                Utils.hideLoading();
            }
        },

        async enriquecerTicketsConColaborador(tickets) {
            if (!tickets || tickets.length === 0) return tickets;
            
            try {
                // Obtener datos del colaborador responsable
                const colaboradorRef = doc(db, 'colaboradores', AppState.userData.colaboradorId);
                const colaboradorSnap = await getDoc(colaboradorRef);
                
                if (!colaboradorSnap.exists()) {
                    console.warn("No se encontró el documento del colaborador");
                    return tickets;
                }
                
                const datosColaborador = colaboradorSnap.data();
                console.log("Datos del colaborador:", datosColaborador);
                
                // Añadir datos del colaborador a cada ticket
                return tickets.map(ticket => ({
                    ...ticket,
                    colaborador: {
                        nombre: datosColaborador.NOMBRE,
                        area: datosColaborador.ÁREA,
                        puesto: datosColaborador.PUESTO,
                        imagen: datosColaborador.imagen || null
                    }
                }));
                
            } catch (error) {
                console.error("Error enriqueciendo tickets:", error);
                return tickets;
            }
        },

        async showTicketDetails(ticketId) {
            try {
                Utils.showLoading('Cargando detalles...');
                
                const ticketRef = doc(db, 'ticketsmesa', ticketId);
                const ticketSnap = await getDoc(ticketRef);
                
                if (!ticketSnap.exists()) {
                    throw new Error('El ticket no existe');
                }
                
                const data = ticketSnap.data();
                const shortId = ticketId.substring(0, 8);
                
                // Actualizar el estado en ticketManager
                ticketManager.setCurrentTicket(ticketId, data.estado);
                
                // Obtener nombres de colaboradores
                let nombresColaboradores = [];
                if (data.colaboradores && data.colaboradores.length > 0) {
                    const colaboradoresPromises = data.colaboradores.map(async colabId => {
                        const colabRef = doc(db, 'colaboradores', colabId);
                        const colabSnap = await getDoc(colabRef);
                        return colabSnap.exists() ? colabSnap.data().NOMBRE : 'Colaborador desconocido';
                    });
                    nombresColaboradores = await Promise.all(colaboradoresPromises);
                }
                
                // Obtener todas las evidencias para este ticket
                const evidenciasRef = collection(db, 'evidenciatickets');
                const q = query(evidenciasRef, where("ticketId", "==", ticketId));
                const evidenciasSnap = await getDocs(q);
                
                const evidencias = [];
                evidenciasSnap.forEach(doc => {
                    evidencias.push(doc.data());
                });
                
                // Configurar botones según si el usuario ya subió evidencias
                const finishBtn = document.getElementById('finishTicketBtn');
                const editBtn = document.getElementById('editFinishBtn');
                
                // Definir userEvidence aquí antes de usarla
                const userEvidence = evidencias.find(
                    ev => ev.colaboradorId === AppState.userData.colaboradorId
                );
                
                // Configurar botones
                const ticketEstaFinalizado = data.estado === 'finalizado';
                const usuarioYaCompleto = !!userEvidence;

                if (ticketEstaFinalizado) {
                    finishBtn.style.display = 'none';
                    editBtn.style.display = 'none';
                } else if (usuarioYaCompleto) {
                    finishBtn.style.display = 'none';
                    editBtn.style.display = 'inline-flex';
                } else {
                    finishBtn.style.display = 'inline-flex';
                    editBtn.style.display = 'none';
                }
                
                // **CORRECCIÓN: Actualizar el href del botón de finalizar para redirigir al panel de editar ticket**
                if (finishBtn) {
                    finishBtn.href = `../editar-ticket/editar-ticket.html?ticketId=${ticketId}`;
                    console.log('Botón de finalizar configurado con URL:', finishBtn.href);
                }
                
                // **CORRECCIÓN: Configurar también el botón de editar para redirigir al panel de editar ticket**
                if (editBtn && usuarioYaCompleto) {
                    editBtn.onclick = () => {
                        window.location.href = `../editar-ticket/editar-ticket.html?ticketId=${ticketId}&edit=true`;
                    };
                }
                
                // Mostrar detalles del ticket
                const modal = document.getElementById('detailModal');
                const detailContent = document.getElementById('detailContent');
                
                // Crear HTML para el progreso de colaboradores
                let progressHTML = '';
                if (data.colaboradores && data.colaboradores.length > 1) {
                    progressHTML = `
                        <div class="detail-section">
                            <strong>Progreso de Colaboradores</strong>
                            <div class="progress-container">
                                ${data.colaboradores.map((colabId, index) => {
                                    const evidenciaColab = evidencias.find(ev => ev.colaboradorId === colabId);
                                    const completado = !!evidenciaColab;
                                    const nombreColab = nombresColaboradores[index] || 'Colaborador';
                                    
                                    return `
                                        <div class="progress-item">
                                            <span class="progress-name">${nombreColab}</span>
                                            <span class="progress-status ${completado ? 'completed' : 'pending'}">
                                                <i class="fas ${completado ? 'fa-check-circle' : 'fa-clock'}"></i>
                                                ${completado ? 'Completado' : 'Pendiente'}
                                            </span>
                                            ${completado ? `
                                                <button class="view-evidence-btn" data-colab-id="${colabId}">
                                                    <i class="fas fa-eye"></i>
                                                </button>
                                                
                                            ` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }
                
                // Crear HTML para las imágenes del usuario actual si existen
                let userEvidenceHTML = '';
                if (userEvidence) {
                    userEvidenceHTML = `
                        <div class="detail-section">
                            <strong>Mis Evidencias</strong>
                            <div class="description-text">${userEvidence.descripcion}</div>
                            <div class="evidence-grid">
                                ${userEvidence.imagenes.map(img => `
                                    <img src="${img}" class="evidence-img clickable-image" 
                                        alt="Mi evidencia" style="cursor: pointer; max-height: 150px;"
                                        onclick="openImageModal('${img}')">
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                // Crear HTML para información adicional del ticket
                let additionalInfoHTML = '';
                if (data.servicio || data.proyecto || data.ordenServicio || data.descripcionActividades) {
                    additionalInfoHTML = `
                        <div class="detail-section">
                            <strong>Información Adicional</strong>
                            ${data.servicio ? `<p><span class="detail-label">Servicio:</span> ${data.servicio}</p>` : ''}
                            ${data.proyecto ? `<p><span class="detail-label">Proyecto:</span> ${data.proyecto}</p>` : ''}
                            ${data.ordenServicio ? `<p><span class="detail-label">Orden de Servicio:</span> ${data.ordenServicio}</p>` : ''}
                            ${data.descripcionActividades ? `<p><span class="detail-label">Actividades:</span> ${data.descripcionActividades}</p>` : ''}
                        </div>
                    `;
                }
                
                // Crear HTML para información fiscal si existe
                let fiscalInfoHTML = '';
                if (data.rfc || data.direccionFiscal || data.cuenta) {
                    fiscalInfoHTML = `
                        <div class="detail-section">
                            <strong>Información Fiscal</strong>
                            ${data.rfc ? `<p><span class="detail-label">RFC:</span> ${data.rfc}</p>` : ''}
                            ${data.direccionFiscal ? `<p><span class="detail-label">Dirección Fiscal:</span> ${data.direccionFiscal}</p>` : ''}
                            ${data.cuenta ? `<p><span class="detail-label">Cuenta:</span> ${data.cuenta}</p>` : ''}
                        </div>
                    `;
                }
                
                // Crear HTML para sistemas si existen
                let sistemasHTML = '';
                if (data.sistemas && Object.keys(data.sistemas).length > 0) {
                    sistemasHTML = `
                        <div class="detail-section">
                            <strong>Sistemas Relacionados</strong>
                            <ul>
                                ${Object.entries(data.sistemas).map(([key, value]) => `
                                    <li>${key}: ${value}</li>
                                `).join('')}
                            </ul>
                        </div>
                    `;
                }
                
                detailContent.innerHTML = `
                    <div style="text-align: left;">
                        <div class="detail-section">
                            <strong>Información Básica</strong>
                            <p><span class="detail-label">ID:</span> #${shortId.toUpperCase()}</p>
                            <p><span class="detail-label">Título:</span> ${data.titulo}</p>
                            <p><span class="detail-label">Estado:</span> 
                                <span class="badge ${Utils.getBadgeClass(data.estado)}">
                                    <i class="fas ${Utils.getStatusIcon(data.estado)}"></i> ${data.estado.replace('_', ' ')}
                                </span>
                            </p>
                            <p><span class="detail-label">Prioridad:</span> 
                                <span class="badge badge-primary">
                                    <span class="priority-indicator ${Utils.getPriorityClass(data.prioridad)}"></span> 
                                    ${data.prioridad}
                                </span>
                            </p>
                            <p><span class="detail-label">Área:</span> 
                                <span class="badge badge-primary">
                                    <i class="fas fa-layer-group"></i> ${data.area || 'General'}
                                </span>
                            </p>
                            <p><span class="detail-label">Responsable:</span> ${data.responsableNombre}</p>
                            <p><span class="detail-label">Colaboradores:</span> ${nombresColaboradores.join(', ')}</p>
                            <p><span class="detail-label">Fecha creación:</span> ${Utils.formatDate(data.fechaCreacion)}</p>
                            ${data.fechaActualizacion ? `<p><span class="detail-label">Última actualización:</span> ${Utils.formatDate(data.fechaActualizacion)}</p>` : ''}
                            ${data.fechaFinalizacion ? `<p><span class="detail-label">Fecha finalización:</span> ${Utils.formatDate(data.fechaFinalizacion)}</p>` : ''}
                        </div>
                        
                        ${progressHTML}
                        
                        <div class="detail-section">
                            <strong>Descripción</strong>
                            <div class="description-text">${data.descripcionActividades}</div>
                        </div>
                        
                        ${additionalInfoHTML}
                        ${fiscalInfoHTML}
                        ${sistemasHTML}
                        ${userEvidenceHTML}
                    </div>
                `;
                
                // Configurar event listeners para los botones de evidencias
                document.querySelectorAll('.view-evidence-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const colabId = btn.dataset.colabId;
                        const evidencia = evidencias.find(ev => ev.colaboradorId === colabId);
                        if (evidencia) {
                            Swal.fire({
                                title: `Evidencias de ${evidencia.colaboradorNombre}`,
                                html: `
                                    <div style="text-align: left; margin-bottom: 20px;">
                                        <p><strong>Descripción:</strong></p>
                                        <div class="description-text">${evidencia.descripcion}</div>
                                    </div>
                                    <div class="evidence-grid">
                                        ${evidencia.imagenes.map(img => `
                                            <img src="${img}" class="evidence-img clickable-image" 
                                                alt="Evidencia" style="cursor: pointer; max-height: 300px;"
                                                onclick="openImageModal('${img}')">
                                        `).join('')}
                                    </div>
                                `,
                                width: '80%',
                                confirmButtonText: 'Cerrar',
                                
                                background: '#1e1e1e',
                                color: '#ffffff'
                            });
                        }
                    });
                });

                function openImageModal(imgSrc) {
                    Swal.fire({
                        imageUrl: imgSrc,
                        imageAlt: 'Evidencia en tamaño completo',
                        background: '#1e1e1e',
                        padding: '1em',
                        showConfirmButton: false,
                        width: 'auto',
                    });
                }

                // Configurar event listeners para los botones de PDF
                document.querySelectorAll('.print-pdf-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        const ticketId = btn.dataset.ticketId;
                        await this.generateTicketPDF(ticketId);
                    });
                });
                
                modal.style.display = 'block';
                
            } catch (error) {
                console.error("Error mostrando detalles:", error);
                Utils.showError("No se pudieron cargar los detalles del ticket");
            } finally {
                Utils.hideLoading();
            }
        },

        async generateTicketPDF(ticketId) {
            try {
                // Obtener datos del ticket
                const ticketRef = doc(db, 'ticketsmesa', ticketId);
                const ticketSnap = await getDoc(ticketRef);
                
                if (!ticketSnap.exists()) {
                    throw new Error('El ticket no existe');
                }
                
                const ticketData = { id: ticketId, ...ticketSnap.data() };
                
                // Obtener evidencias
                const evidenciasRef = collection(db, 'evidenciatickets');
                const q = query(evidenciasRef, where("ticketId", "==", ticketId));
                const evidenciasSnap = await getDocs(q);
                
                const evidencias = [];
                evidenciasSnap.forEach(doc => {
                    evidencias.push(doc.data());
                });
                
                // Generar PDF
                await pdfGenerator.generateTicketPDF(ticketData, evidencias);
                
            } catch (error) {
                console.error('Error generando PDF:', error);
                Utils.showError('No se pudo generar el PDF: ' + error.message);
            }
        },

        async checkForNewTickets() {
            try {
                if (!AppState.userData || !AppState.userData.nombreCompleto) return false;
                
                const ticketsRef = collection(db, 'ticketsmesa');
                const q = query(
                    ticketsRef,
                    where("responsableNombre", "==", AppState.userData.nombreCompleto),
                    where("notificacion", "==", false), // Solo tickets no notificados
                    orderBy("fechaCreacion", "desc"),
                    limit(1)
                );
                
                const querySnapshot = await getDocs(q);
                
                if (!querySnapshot.empty) {
                    const latestTicket = querySnapshot.docs[0];
                    const ticketId = latestTicket.id;
                    const ticketRef = doc(db, 'ticketsmesa', ticketId);
                    const ticketData = latestTicket.data();
                    
                    // Mostrar notificación
                    const notificationShown = await Utils.showNotification(
                        'Nuevo Ticket Asignado - RSI',
                        `Tienes un nuevo ticket: "${ticketData.titulo || 'Nuevo ticket sin título'}"`,
                        ticketId
                    );
                    
                    if (notificationShown) {
                        // Actualizar el campo notificacion a true solo si se mostró la notificación
                        await updateDoc(ticketRef, {
                            notificacion: true
                        });
                        
                        // Actualizar el último ticket verificado
                        AppState.lastCheckedTicketId = ticketId;
                        
                        // Recargar los tickets para reflejar el cambio
                        await this.loadUserTickets();
                        
                        return true;
                    }
                }
                return false;
            } catch (error) {
                console.error("Error verificando nuevos tickets:", error);
                return false;
            }
        }
    };
    
    // Controlador de autenticación
    const AuthController = {
        async signInWithGoogle() {
            try {
                Utils.showLoading('Iniciando sesión...');
                const result = await signInWithPopup(auth, provider);
                AppState.currentUser = result.user;
                console.log('Usuario autenticado:', result.user);
                await this.verifyUserAccess(AppState.currentUser.email);
            } catch (error) {
                console.error("Error al iniciar sesión:", error);
                Utils.showError(error.message || 'No se pudo iniciar sesión');
            }
        },
        
        async verifyUserAccess(email) {
            try {
                Utils.showLoading('Verificando acceso...');
                
                console.log('Verificando acceso para:', email);
                
                // 1. Verificar en la colección 'usuarios'
                const usuariosRef = collection(db, 'usuarios');
                const q = query(usuariosRef, where("email", "==", email));
                const userSnapshot = await getDocs(q);
                
                if (userSnapshot.empty) {
                    throw new Error('No tienes acceso a esta plataforma');
                }
                
                // Obtener rol del usuario
                let userRole = null;
                userSnapshot.forEach(doc => {
                    userRole = doc.data().rol;
                    console.log('Rol del usuario:', userRole);
                });
                
                // Permitir acceso a todos excepto a los que tengan rol 'user'
                if (userRole === 'user') {
                    throw new Error('No tienes permisos para acceder a esta sección');
                }
                
                AppState.userRole = userRole;
                
                // Mostrar botón de crear ticket solo para admincolaborador
                if (userRole === 'admincolaborador') {
                    const createTicketBtn = document.getElementById('createTicketBtn');
                    if (createTicketBtn) {
                        createTicketBtn.style.display = 'block';
                    }
                }
                
                // 2. Obtener datos del colaborador
                const colaboradoresRef = collection(db, 'colaboradores');
                const q2 = query(colaboradoresRef, where("CORREO ELECTRÓNICO EMPRESARIAL", "==", email));
                const collabSnapshot = await getDocs(q2);
                
                if (collabSnapshot.empty) {
                    throw new Error('No se encontraron tus datos de colaborador');
                }
                
                collabSnapshot.forEach(doc => {
                    AppState.userData = doc.data();
                    AppState.userData.colaboradorId = doc.id;
                    AppState.userData.nombreCompleto = doc.data()['NOMBRE'];
                    console.log("Datos del colaborador cargados:", AppState.userData);
                });
                
                // Actualizar UI
                this.updateUserProfile();
                
                // Cargar tickets del usuario
                await TicketsController.loadUserTickets();
                
                // Configurar intervalo para verificar nuevos tickets
                this.setupTicketCheckInterval();
                
            } catch (error) {
                console.error("Error verificando acceso:", error);
                await this.signOut();
                Utils.showError(error.message);
            } finally {
                Utils.hideLoading();
            }
        },
        
        updateUserProfile() {
            if (!AppState.userData) return;
            
            const userAvatar = DOM.userAvatar;
            const userNameDisplay = DOM.userNameDisplay;
            const userAreaDisplay = DOM.userAreaDisplay;
            
            if (userAvatar) {
                userAvatar.src = AppState.userData.imagen || 
                               'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png';
            }
            
            if (userNameDisplay && AppState.userData.NOMBRE) {
                userNameDisplay.textContent = AppState.userData.NOMBRE;
            }
            
            if (userAreaDisplay && AppState.userData.ÁREA) {
                userAreaDisplay.textContent = `ÁREA: ${AppState.userData.ÁREA}`;
            }
        },
        
        async signOut() {
            try {
                // Evitar múltiples ejecuciones
                if (this._isLoggingOut) return;
                this._isLoggingOut = true;
                
                Utils.showLoading('Cerrando sesión...');
                await signOut(auth);
                
                // Limpiar estado
                AppState.currentUser = null;
                AppState.userData = null;
                AppState.userRole = null;
                
                // Limpiar UI
                if (DOM.userAvatar) {
                    DOM.userAvatar.src = 'https://rsienterprise.web.app/vista/css/img/logocon%20fondo.png';
                }
                if (DOM.userNameDisplay) {
                    DOM.userNameDisplay.textContent = 'Usuario no autenticado';
                }
                if (DOM.userAreaDisplay) {
                    DOM.userAreaDisplay.textContent = 'ÁREA: No disponible';
                }
                
                // Cerrar cualquier modal abierto
                const modals = document.querySelectorAll('.modal');
                modals.forEach(modal => modal.style.display = 'none');
                
                // Redirección única con reemplazo en el historial
                window.location.replace('/vista/nav-visitantes/inicio-de-sesion.html');
                
            } catch (error) {
                console.error("Error al cerrar sesión:", error);
                Utils.showError('No se pudo cerrar la sesión correctamente');
            } finally {
                this._isLoggingOut = false;
                Utils.hideLoading();
            }
        },
        
        setupTicketCheckInterval() {
            // Limpiar intervalo anterior si existe
            if (AppState.ticketCheckInterval) {
                clearInterval(AppState.ticketCheckInterval);
            }
            
            // Configurar nuevo intervalo
            const checkTickets = async () => {
                const hadNewTickets = await TicketsController.checkForNewTickets();
                
                if (hadNewTickets) {
                    // Si hubo notificaciones, aumentar el intervalo temporalmente
                    clearInterval(AppState.ticketCheckInterval);
                    AppState.notificationCheckInterval = 30000; // 30 segundos
                    
                    AppState.ticketCheckInterval = setInterval(checkTickets, AppState.notificationCheckInterval);
                } else {
                    // Volver al intervalo normal si no hay notificaciones
                    if (AppState.notificationCheckInterval !== 10000) {
                        clearInterval(AppState.ticketCheckInterval);
                        AppState.notificationCheckInterval = 10000; // 10 segundos
                        
                        AppState.ticketCheckInterval = setInterval(checkTickets, AppState.notificationCheckInterval);
                    }
                }
            };
            
            // Iniciar el intervalo
            AppState.ticketCheckInterval = setInterval(checkTickets, AppState.notificationCheckInterval);
        },
        
        initializeAuthListener() {
            onAuthStateChanged(auth, async (user) => {
                console.log('Estado de autenticación cambió:', user ? 'Autenticado' : 'No autenticado');
                if (user) {
                    AppState.currentUser = user;
                    try {
                        await this.verifyUserAccess(user.email);
                    } catch (error) {
                        console.error("Error en auth listener:", error);
                    }
                } else {
                    console.log('Usuario no autenticado, iniciando proceso de login...');
                    this.signInWithGoogle();
                }
            });
        }
    };

    // Event Listeners
    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM cargado, inicializando aplicación...');
        
        // Configurar evento de logout
        if (DOM.logoutBtn) {
            DOM.logoutBtn.addEventListener('click', () => {
                AuthController.signOut();
            });
        }

        /* ELIMINADO: Evento para el botón de terminar asistencia
        if (DOM.endAssistanceBtn) {
            DOM.endAssistanceBtn.addEventListener('click', async () => {
                await AssistanceController.endAssistance();
            });
        }
        */

        // Configurar el filtro de tickets
        if (DOM.filterBtn) {
            DOM.filterBtn.addEventListener('click', () => {
                const showFinalized = ticketManager.toggleFilter();
                if (DOM.filterText) {
                    DOM.filterText.textContent = showFinalized ? 'Ver Activos' : 'Ver Finalizados';
                }
                
                // Re-renderizar tickets con el nuevo filtro
                if (AppState.allTickets.length > 0) {
                    TicketsController.renderTickets(AppState.allTickets);
                }
            });
        }

        
        // Configurar todos los botones de cerrar
        const closeButtons = document.querySelectorAll('.modal .close, .cancel-btn, #closeDetailBtn');
        closeButtons.forEach(btn => {
            btn.addEventListener('click', closeModals);
        });
        
        
        // Event listener para el botón de crear ticket
        const createTicketBtn = document.getElementById('createTicketBtn');
        if (createTicketBtn) {
            createTicketBtn.addEventListener('click', () => {
                window.location.href = '/vista/nav-mesa/gestion-tickets.html';
            });
        }

        // Configurar el botón de finalizar ticket en el modal de detalles
        const finishTicketBtn = document.getElementById('finishTicketBtn');
        if (finishTicketBtn) {
            // El botón ahora es un enlace que redirige al panel de editar ticket
            // El href ya está configurado dinámicamente en showTicketDetails
        }

        // Configurar el botón de editar finalización
        const editFinishBtn = document.getElementById('editFinishBtn');
        if (editFinishBtn) {
            // La lógica del botón de editar se configura dinámicamente en showTicketDetails
        }

        AuthController.initializeAuthListener();
        
        // Hacer Swal disponible globalmente
        window.Swal = Swal;

        // Registrar Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('../../sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registrado:', registration.scope);
                        // Escuchar clics en notificaciones
                        navigator.serviceWorker.addEventListener('message', event => {
                            if (event.data && event.data.action === 'view') {
                                TicketsController.showTicketDetails(event.data.ticketId);
                            }
                        });
                    })
                    .catch(error => {
                        console.log('Error al registrar ServiceWorker:', error);
                    });
            });
        }
    });

    function closeModals(e) {
        // Prevenir comportamiento por defecto si es un evento
        if (e) e.preventDefault();
        
        const modals = ['detailModal', 'imageViewerModal', 'pdfProgressModal'];
        modals.forEach(modalId => {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
            }
        });
        
        // Limpiar el ticket actual
        ticketManager.clearCurrentTicket();
    }

    // Función para abrir el modal con la imagen en grande
    window.openImageModal = function(imageSrc) {
        const modal = document.getElementById('imageViewerModal');
        const img = document.getElementById('expandedImage');
        if (modal && img) {
            img.src = imageSrc;
            modal.style.display = 'block';
        }
    };

    // Función para cerrar el modal de imagen
    function closeImageModal() {
        const modal = document.getElementById('imageViewerModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }

    // Configurar el evento de clic para cerrar el modal de imagen
    const imageModalClose = document.querySelector('#imageViewerModal .close');
    if (imageModalClose) {
        imageModalClose.addEventListener('click', closeImageModal);
    }

    // Cerrar al hacer clic fuera de la imagen
    const imageViewerModal = document.getElementById('imageViewerModal');
    if (imageViewerModal) {
        imageViewerModal.addEventListener('click', function(e) {
            if (e.target === this) {
                closeImageModal();
            }
        });
    }

    // Función para actualizar el estado del ticket
    async function updateTicketStatus(ticketId, newStatus) {
        try {
            Utils.showLoading('Actualizando estado...');
            
            const ticketRef = doc(db, 'ticketsmesa', ticketId);
            
            await updateDoc(ticketRef, {
                estado: newStatus,
                fechaActualizacion: serverTimestamp()
            });
            
            // Si el estado es "cerrado", agregar fecha de finalización
            if (newStatus === 'cerrado') {
                await updateDoc(ticketRef, {
                    fechaFinalizacion: serverTimestamp()
                });
            }
            
            Utils.hideLoading();
            
            Swal.fire({
                icon: 'success',
                title: 'Estado actualizado',
                text: `El estado del ticket ha sido cambiado a ${newStatus.replace(/_/g, ' ')}`,
                confirmButtonColor: '#3085d6'
            });
            
            // Actualizar la vista de detalles si está abierta
            if (document.getElementById('detailModal').style.display === 'block') {
                await TicketsController.showTicketDetails(ticketId);
            }
            
            // Actualizar la lista de tickets
            await TicketsController.loadUserTickets();
            
        } catch (error) {
            console.error("Error actualizando estado:", error);
            Utils.showError('No se pudo actualizar el estado del ticket');
        }
    }

    // Modificamos la función que inserta el select
    const originalShowTicketDetails = TicketsController.showTicketDetails;
    TicketsController.showTicketDetails = async function(ticketId) {
        await originalShowTicketDetails.call(this, ticketId);
        
        // Crear contenedor principal
        const modalContent = document.getElementById('detailContent');
        const statusControl = document.createElement('div');
        statusControl.className = 'status-control-container';
        statusControl.style.cssText = `
            background-color: #2c3e50;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            color: white;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        `;
        
        // Obtener datos del ticket
        const ticketRef = doc(db, 'ticketsmesa', ticketId);
        const ticketSnap = await getDoc(ticketRef);
        const ticketData = ticketSnap.data();
        let currentStatus = ticketData.estado || 'pendiente_de_aceptación';
        let pauseComment = ticketData.pauseComment || '';
        
        // Contenedor para estado + comentario
        const statusInfoContainer = document.createElement('div');
        statusInfoContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex-grow: 1;
        `;
        
        // Badge de estado
        const statusBadge = document.createElement('span');
        statusBadge.className = `current-status-badge ${currentStatus}`;
        statusBadge.textContent = currentStatus.replace(/_/g, ' ');
        statusBadge.style.cssText = `
            font-weight: bold;
            padding: 6px 12px;
            border-radius: 4px;
            text-transform: capitalize;
            margin-bottom: 8px;
            display: inline-block;
            width: fit-content;
            color: ${currentStatus === 'pendiente_de_aceptación' ? '#000' : '#fff'};
            background-color: ${getStatusColor(currentStatus)};
        `;
        statusInfoContainer.appendChild(statusBadge);
        
        // Mostrar comentario existente
        if (currentStatus === 'en_proceso' && pauseComment) {
            const wordCount = pauseComment.trim().split(/\s+/).length;
            const commentBadge = document.createElement('div');
            commentBadge.className = 'pause-comment-badge';
            commentBadge.innerHTML = `
                <div style="border-left: 3px solid #17a2b8; padding-left: 10px;">
                    <strong style="color: white; font-weight: 600;">Razón de pausa:</strong>
                    <p style="color: #e0e0e0; margin: 5px 0 0 0; max-height: 100px; overflow-y: auto; white-space: pre-wrap; line-height: 1.4;">${pauseComment}</p>
                    <div style="color: #aaa; font-size: 0.8em; text-align: right;"></div>
                </div>
            `;
            statusInfoContainer.appendChild(commentBadge);
        }
        
        statusControl.appendChild(statusInfoContainer);
        
        // Selector de estados
        const statusSelect = document.createElement('select');
        statusSelect.className = 'status-select';
        statusSelect.style.cssText = `
            background-color: #333;
            color: white;
            border: 1px solid #444;
            padding: 6px 10px;
            border-radius: 4px;
            min-width: 200px;
        `;
        
        const statusOptions = [
            { value: 'pendiente_de_aceptación', text: 'Pendiente de aceptación' },
            { value: 'aceptado', text: 'Aceptado' },
            { value: 'en_proceso', text: 'En pausa' },
            { value: 'en_camino', text: 'En camino' },
            { value: 'completado', text: 'Completado' },
            { value: 'cerrado', text: 'Cerrado' }
        ];
        
        statusOptions.forEach(option => {
            const optElement = document.createElement('option');
            optElement.value = option.value;
            optElement.textContent = option.text;
            optElement.selected = option.value === currentStatus;
            statusSelect.appendChild(optElement);
        });
        
        statusControl.appendChild(statusSelect);
        
        // Botón de guardar
        const saveButton = document.createElement('button');
        saveButton.className = 'save-status-btn';
        saveButton.innerHTML = '<i class="fas fa-save"></i>';
        saveButton.style.cssText = `
            background-color: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        `;
        
        // --- EVENT LISTENER DEL BOTÓN GUARDAR ---
        saveButton.onclick = async () => {
            const newStatus = statusSelect.value;
            let comment = pauseComment;
            
            if (newStatus === 'en_proceso') {
                const { value: commentText } = await Swal.fire({
                    title: '<span style="color:white">Razón de la pausa</span>',
                    html: `
                        <textarea id="commentTextarea" 
                                    style="background:#222; color:white; border:1px solid #444; width:100%; min-height:100px; padding:10px;"
                                    placeholder="Escribe aquí la razón (máximo 200 palabras)...">${pauseComment}</textarea>
                        <div id="wordCounter" style="color:#aaa; text-align:right; font-size:0.8em;">0/200 palabras</div>
                    `,
                    background: '#000',
                    showCancelButton: true,
                    confirmButtonText: 'Guardar',
                    cancelButtonText: 'Cancelar',
                    preConfirm: () => {
                        const textarea = document.getElementById('commentTextarea');
                        const text = textarea.value.trim();
                        const wordCount = text.split(/\s+/).length;
                        
                        if (!text) {
                            Swal.showValidationMessage('Debes escribir una razón para la pausa');
                            return false;
                        }
                        if (wordCount > 200) {
                            Swal.showValidationMessage(`Has excedido el límite de 200 palabras (${wordCount})`);
                            return false;
                        }
                        return text;
                    },
                    didOpen: () => {
                        const textarea = document.getElementById('commentTextarea');
                        const counter = document.getElementById('wordCounter');
                        
                        textarea.addEventListener('input', () => {
                            const text = textarea.value.trim();
                            const wordCount = text ? text.split(/\s+/).length : 0;
                            counter.textContent = `${wordCount}/200 palabras`;
                        });
                        
                        const initialWordCount = pauseComment ? pauseComment.trim().split(/\s+/).length : 0;
                        counter.textContent = `${initialWordCount}/200 palabras`;
                    }
                });
                
                if (commentText === undefined) return;
                comment = commentText;
            }
            
            try {
                // 1. Prepara los datos para guardar
                const updateData = {
                    estado: newStatus,
                    updatedAt: serverTimestamp(),
                    ...(newStatus === 'en_proceso' ? { pauseComment: comment } : { pauseComment: '' })
                };
                
                // 2. Guarda en la base de datos y ESPERA a que termine
                await updateDoc(ticketRef, updateData);
                
                // ✅ INICIA CÓDIGO PARA ACTUALIZACIÓN INMEDIATA ✅
                // Esta parte se ejecuta DESPUÉS de que la base de datos se actualizó correctamente.
                
                currentStatus = newStatus;
                pauseComment = newStatus === 'en_proceso' ? comment : '';
                
                // 3. Actualiza el badge de estado en el modal
                statusBadge.className = `current-status-badge ${newStatus}`;
                statusBadge.textContent = newStatus.replace(/_/g, ' ');
                statusBadge.style.backgroundColor = getStatusColor(newStatus);
                statusBadge.style.color = newStatus === 'pendiente_de_aceptación' ? '#000' : '#fff';
                
                // 4. Actualiza el comentario de pausa en el modal
                const existingComment = statusInfoContainer.querySelector('.pause-comment-badge');
                if (existingComment) existingComment.remove();
                
                if (newStatus === 'en_proceso' && comment) {
                    const wordCount = comment.trim().split(/\s+/).length;
                    const commentBadge = document.createElement('div');
                    commentBadge.className = 'pause-comment-badge';
                    commentBadge.innerHTML = `
                        <div style="border-left: 3px solid #17a2b8; padding-left: 10px;">
                            <strong style="color: white; font-weight: 600;">Razón de pausa:</strong>
                            <p style="color: #e0e0e0; margin: 5px 0 0 0; max-height: 100px; overflow-y: auto; white-space: pre-wrap; line-height: 1.4;">${comment}</p>
                            <div style="color: #aaa; font-size: 0.8em; text-align: right;">${wordCount}/200 palabras</div>
                        </div>
                    `;
                    statusInfoContainer.appendChild(commentBadge);
                }
                
                // ✅ TERMINA CÓDIGO PARA ACTUALIZACIÓN INMEDIATA ✅
                
                // 5. Muestra la alerta de éxito
                await Swal.fire({
                    icon: 'success',
                    title: '¡Actualizado!',
                    text: 'El estado del ticket ha sido actualizado',
                    timer: 1500,
                    showConfirmButton: false,
                    background: '#000',
                    color: 'white'
                });
                
            } catch (error) {
                console.error("Error updating ticket: ", error);
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: 'No se pudo actualizar el ticket: ' + error.message,
                    background: '#000',
                    color: 'white'
                });
            }
        };
        
        statusControl.appendChild(saveButton);
        modalContent.insertBefore(statusControl, modalContent.firstChild);
    };

    // Función auxiliar para colores de estado
    function getStatusColor(status) {
        const colors = {
            'pendiente_de_aceptación': '#ffc107',
            'aceptado': '#17a2b8',
            'en_proceso': '#fd7e14',
            'en_camino': '#007bff',
            'completado': '#28a745',
            'cerrado': '#6c757d'
        };
        return colors[status] || '#6c757d';
    }
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Crear botón hamburguesa
        const hamburgerBtn = document.createElement('button');
        hamburgerBtn.className = 'sidebar-toggle';
        hamburgerBtn.innerHTML = '<span></span><span></span><span></span>';
        document.body.appendChild(hamburgerBtn);

        // Crear overlay
        const overlay = document.createElement('div');
        overlay.className = 'sidebar-overlay';
        document.body.appendChild(overlay);

        // Elementos existentes
        const sidebar = document.querySelector('.sidebar');
        const mainContent = document.querySelector('.main-content');

        // Evento para abrir/cerrar menú
        hamburgerBtn.addEventListener('click', function() {
            this.classList.toggle('active');
            sidebar.classList.toggle('active');
            overlay.classList.toggle('active');
            document.body.classList.toggle('menu-open');
        });

        // Cerrar menú al hacer clic en overlay
        overlay.addEventListener('click', function() {
            hamburgerBtn.classList.remove('active');
            sidebar.classList.remove('active');
            this.classList.remove('active');
            document.body.classList.remove('menu-open');
        });

        // Cerrar menú al hacer clic en enlaces del sidebar
        const sidebarLinks = document.querySelectorAll('.sidebar a, .sidebar button');
        sidebarLinks.forEach(link => {
            link.addEventListener('click', function() {
                // Solo cerrar si es un enlace (no botones de acción)
                if (this.tagName === 'A') {
                    hamburgerBtn.classList.remove('active');
                    sidebar.classList.remove('active');
                    overlay.classList.remove('active');
                    document.body.classList.remove('menu-open');
                }
            });
        });

        // Mejorar accesibilidad
        hamburgerBtn.setAttribute('aria-label', 'Menú de navegación');
        hamburgerBtn.setAttribute('aria-expanded', 'false');
        
        hamburgerBtn.addEventListener('click', function() {
            const expanded = this.classList.contains('active');
            this.setAttribute('aria-expanded', expanded);
            sidebar.setAttribute('aria-hidden', !expanded);
        });
    });

    </script>

    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
</body>
</html>